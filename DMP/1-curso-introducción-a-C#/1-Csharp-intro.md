# Curso de Introducci√≥n a C#

> **Ricardo Celis** - [Faculty Manager en Platzi](https://platzi.com/profesores/celismx/)      
> **@CelisMX** en Twitter 


## 1. ¬øPor qu√© aprender C#? ¬øPara qu√© sirve?

C# fue un lenguaje que¬†**Microsoft**¬†comenz√≥ a desarrollar a finales de los 90.

En el a√±o 2002 sali√≥ la versi√≥n 1.0 del lenguaje, ya con todos su est√°ndares que pueda tener, fue su gran lanzamiento.

A lo largo de los a√±os C# a evolucionado bastante, hoy en d√≠a esta en la versi√≥n 8.0.

C# tiene gran demanda en:    

-   Mundo Web, utilizando .NET Framework
-   Desarrollo de video juegos, a trav√©s del motor de desarrollo de juegos Unity Engine.
-   En las aplicaciones h√≠bridas, donde uno puede hacer aplicaciones que exporten a IOS o Android gracias a Xamarin.

[Para complementar tus conocimientos y tener √©xito en este curso!](https://docs.microsoft.com/es-es/learn/paths/csharp-first-steps/)

üé≤

## 2. Instalaci√≥n de Visual Studio Community

Como herramientas tenemos:

### **Visual Studio Code**  
Nos va ayudar en temas que tiene que ver con la web, es un¬†**EDITOR DE C√ìDIGO**¬†que nos ayudara en todos los lenguajes que sirven en todas las plataformas.

### **Visual Studio** üî•  
Es mas robusto, permite hacer interfaz grafica, es un¬†**IDE**, esta enfocado en cargas de trabajo web, escritorio, m√≥vil, juegos y otros.   
[Comparar versiones](https://visualstudio.microsoft.com/es/vs/compare/)

[VS.Microsoft](https://visualstudio.microsoft.com/)     
**Download Visual Studio:** ‚û° Community 2022

![Download](https://i.postimg.cc/MZnqQ7yw/2-download.png)    
**VisualStudioSetup.exe** üëà
- Doble clic sobre el ejecutable
- Visual Studio Installer: Continuar

![Download-more](https://i.postimg.cc/hvNSXjCV/2-download-csharp.png)    
**Workloads** (Cargas de trabajo)    
Es el flujo o las herramientas que se van a usar d√≠a a dia.    
- üåê ASP.NET and web development 
- üñ• .NET desktop development 

**Individual components** - Buscar **C#** üîç  
- Compilers, build tools, and runtimes 
	- ‚úÖ C# and Visual Basic Roslyn compilers
	- ‚úÖ MSBuild 
- Development activities 
	- ‚úÖ C# and Visual Basic 

**Language packs**  
- English 
- Spanish 

Install while downloading: üîµ **Install**    

![Finish download](https://i.postimg.cc/ydbM6GdG/2-download-finish.png)

Para finalizar:
- Elije un tema üßõ‚Äç‚ôÇÔ∏è
- Start Visual Studio 
- Sign in: Inicia sesi√≥n con email Microsoft 

#### ‚ùÑ Computadoras de bajos recursos üò•üò™
Se recomienda probar con Visual Studio Code.

Para usar C# con VS code debemos:

1.  Instalar Visual Studio Code.  
    [https://code.visualstudio.com/download](https://code.visualstudio.com/download)
2.  Instalar .Net Core.  
    [https://dotnet.microsoft.com/en-us/download](https://dotnet.microsoft.com/en-us/download)
3.  Instalar C# plugin para Visual Studio Code.

Aqu√≠ est√°n algunos tutoriales:

- [Create c-sharp project with vsc](https://www.tutorialkart.com/c-sharp-tutorial/create-csharp-project-with-visual-studio-code/)
- [Visual Studio Code c-sharp](https://folderit.net/es/blog/visual-studio-code-c-sharp-es/#)

üé≤

## 3. Conoce .NET 6
En la clase anterior acabamos de instalar Visual Studio Community 2019. Sin embargo, Microsoft recientemente lanz√≥ la versi√≥n 2022, pero‚Ä¶ ¬øqu√© cambia exactamente? ¬øMe impedir√° seguir el curso? ¬øDebo instalar otra versi√≥n? ü§î‚Ä¶ Bien, comparemos estas versiones üòâ.¬†**Spoiler:**¬†Esto no te impedir√° continuar con el curso, pero te ense√±ar√© a trabajar con esta versi√≥n üëÄ.

En la versi√≥n 2019 de Visual Studio usamos .NET en su versi√≥n 3.1. Entre las principales caracter√≠sticas de esta versi√≥n resalta el hecho de que debemos escribir toda la estructura de clases y namespaces en nuestro programa:

```cs
using System;

namespace HelloWorld
{
	class Program
	{
		static void Main(string[] args)
		{
			Console.WriteLine("Hello, World!");
		}
	}
}
```

¬°Pero esto ya no es necesario en Visual Studio 2022! Esta versi√≥n del IDE utiliza por defecto a .NET en su versi√≥n 6, y es gracias a esta versi√≥n que podemos empezar a escribir directamente nuestro programa, sin tener la estructura base üòé:

```csharp
//Gracias a .NET Framework 6.0 ya no necesitamos definir toda la estructura,
//sino que ahora puedo empezar a escribir c√≥digo directamente.
Console.WriteLine("Hello, World!");
```

Aunque .NET permite esto, algunas veces querr√°s trabajar con diferentes namespaces, o incluso querr√°s tener el control por tu propia cuenta de la clase con la que quieres trabajar; es por eso que tambi√©n tienes la posibilidad de escribir la estructura de clases de siempre para que puedas tener todo el control de tu programa.

### ¬øY qu√© pasa si yo quiero usar la versi√≥n que usa el profesor en las clases?
¬°Eso no es ning√∫n problema! Como ya te mencion√©, esa es la versi√≥n 3.1 de .Net, esta versi√≥n ya viene por defecto en Visual Studio 2019, pero si est√°s usando Visual Studio 2022 la puedes descargar‚Ä¶ ¬øadivinas de d√≥nde? üëÄ.

Cuando instalamos Visual Studio tambi√©n se nos instal√≥ una aplicaci√≥n llamada ‚ÄúVisual Studio Installer‚Äù. En esta aplicaci√≥n t√∫ puedes a√±adir o quitar funcionalidades de tu IDE, pero eso lo profundizaremos en la pr√≥xima clase. Por ahora, busca esa aplicaci√≥n dentro de tus programas, √°brela y dale en **modificar**.

![vs installer](https://i.postimg.cc/9fSXF9VX/3-vs-installer.png)   
![vs modificar](https://i.postimg.cc/FzX90Q72/3-vs-modificar.png)

Dentro de ella debemos ir a la pesta√±a ‚ÄúComponentes Individuales‚Äù y aqu√≠ deber√°s seleccionar la opci√≥n que dice ‚Äú.NET Core 3.1 Runtime (LTS)‚Äù

![.net-core-3.1](https://i.postimg.cc/SsMSXKN6/3-net-core-3-1-runtime-LTS.png)   
Install while downloading: üõ°¬†**Modificar**

Una vez seleccionada debes hacer click sobre el bot√≥n ‚ÄúModify‚Äù o ‚ÄúModificar‚Äù y esto a√±adir√° .NET Core 3.1 a tu IDE, simplemente debes reiniciarlo cuando termine.

Con esto listo, cuando crees un nuevo proyecto o soluci√≥n, en la ventana de configuraci√≥n de tu nuevo proyecto ver√°s una opci√≥n que dice ‚ÄúFramework‚Äù. En ese campo podr√°s seleccionar entre la versi√≥n 3.1 o la versi√≥n 6 (o cualquier otra versi√≥n que hayas instalado).

![Elegir versi√≥n 3.1](https://i.postimg.cc/rF5wswFG/3-elegir-version.png)
> Esto sale al seguir los pasos para crear un nuevo proyecto 

Recuerda que la versi√≥n 3.1 es la que estaremos usando durante la mayor√≠a de clases el curso, pero t√∫ puedes usar la versi√≥n 6 sin problemas üòâ.

Como dato adicional, el proyecto que encontrar√°s en la secci√≥n de recursos de cada una de las clases estar√° hecho bajo la versi√≥n 3.1, esto para que sea compatible con quienes a√∫n use la versi√≥n 2019 üíö.

üëã Nos vemos en la siguiente clase donde seguiremos profundizando en nuestro IDE.


### ‚ùÑ Peque√±o resumen acerca de las versiones de .NET:
-   .NET Framework (4.8) = Aplicaciones solo para Windows
-   .NET Core (3.1) = Version Opensource que es multiplataforma.
-   .NET 5 (y luego la 6) = Version m√°s reciente que unifica .NET Core con .NET Framework, opensource y multiplataforma

[Terminolog√≠a .NET vs .NET Core vs .NET Framework vs .NET Standard ü§Ø ¬°Fuera DUDAS!](https://www.youtube.com/watch?v=zWfIl2Za-es)

üé≤

## 4. Introducci√≥n a Visual Studio y nuestro primer "Hola, mundo" en consola

### Crear Proyecto usando .NET Core 3.1
- Create a new project

1. **Console App**  
	A project for creating a command-line application that can run on .NET on Windows, Linux and macOS
	- Console App (.NET Core) = **Console Application** 
		- C# - Linux - macOS - Windows - Console 

2. **Configure Your new project**  
	Name, location, solution, solution name‚Ä¶
	- helloWorldPlazi
	- Siguiente

3.  **Additional Information**  
    Framework¬†**.NET Core 3.1 (Long-term support)**
	- Aqu√≠ puedes cambiar el Framework
	- Create

[Explicaci√≥n de la arquitectura de este programa](https://platzi.com/clases/1032-c-sharp-2017/9790-arquitectura-y-hola-mundo-desde-la-consola/)


```csharp
using System;

namespace helloWorldPlazi
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello Platzi!");
        }
    }
}
```

Para probar picarle a:
- ‚ñ∂ helloWorldPlatzi   
	Aparecer√° una consola con el texto impreso. 


‚ùÑ Pesta√±a Extensions    
- Manage Extensions 
	- Code stream 

‚ùÑ Pesta√±a Window   
- Reset Window Layout: Cambiar el layout 

‚ú®Cuando el compilador devuelve code 0, este es el exit code del ejecutable el que es 0, (NO ES el exit code del compilador) cuando un programa tiene un exit code igual a 0 es que termino correctamente, otro n√∫mero indica un error en la ejecuci√≥n, esto es bien sabido sobre todo cuando han programado en C o cuando han usado BASH en Linux y ejecutan comandos, el exit core de un programa sirve para saber si no hubo error.

üé≤

## 5. ¬°Nuestro primer "Hola, mundo" en una aplicaci√≥n gr√°fica!

üî• Dentro del IDE   
- File
- New
- Project 
- Buscar WPF: Windows presentation foundation 
	- `WPF App (.NET Framework)` 
	- **Aplicaci√≥n de WPF (.NET Framework)**
		- C# - XAML - Windows - Escritorio 
- Siguiente 
- name: helloWorldGrafico 
- Create 

üî• Dentro del proyecto: `MainWindow.xaml`    
Panel izquierdo:    
- `ToolBox` / Cuadro de herramientas
- Common WPF Controls 
	- Label: Arrastrar hacia el recuadro blanco 
	
Al seleccionar el objeto aparece un panel de propiedades del lado inferior derecho, aqu√≠ puedes cambiar la fuente del texto, etc.

Panel superior:   
- ‚ñ∂ Start / Iniciar

### WPF:  
Windows Presentation Foundation    
Tecnolog√≠a para desarrollar interfaces de interacci√≥n en Windows.

### XAML:  
Extensible Application Markup Language    
Lenguaje de marcado para la interfaz de usuario de WPF


[Diferencia entre WPF y WinForms](https://www.geeksforgeeks.org/difference-between-wpf-and-winforms/)

üé≤

## 6. ¬øC√≥mo funcionan los Namespaces en C#?
### **Namespace**: 
Tiene que representar algo significativo para el programa, con un nombre √∫nico. Cada Namespace puede tener diferentes clases, tantas como requiera el programa. üëá

#### **Clases**:
Las clases son plantillas para crear entidades, tantas como se requiera. Cada clase puede tener diferentes m√©todos. üëá
   
##### **M√©todos**: 
La forma o manera de ejecutar funcionalidades del programa.

üî• Veamos un ejemplo:   
Cerrar todos los archivos dentro del IDE luego....    
- File
- Open 
- Project or solution 
- üóÇ Repos
- Entramos: üìÇhelloWorldPlatzi
- Seleccionar archivo `.sln` / solution 
- Open

```cs
using System; 

namespace helloWorldPlazi                //üëàüëÄ Namespace: unique
{
    internal class Program               //üëàüëÄ Class
    {
        static void Main(string[] args)  //üëàüëÄ Method
        {
            Console.WriteLine("Hello Platzi!"); //üëàüëÄ Statement 
        }
    }
}
```


### ‚ùÑ C√≥mo definir un Namespace en C#
**Nota de Platzi: Si programas en C#, los Namespaces pueden hacer tu vida m√°s f√°cil. En este guest post, nuestro estudiante Juan Castro Lurita nos explica por qu√©.**¬†En C#¬†los Namespaces se componen de¬†un¬†conjunto de objetos relacionados como clases, delegados, estructuras, interfaces, etc. As√≠ mismo¬†**con los Namespaces organizamos mejor nuestro¬†c√≥digo**¬†y lo mantenemos¬†bien limpio y estructurado. Una vez definido el Namespace en un archivo aparte, podemos acceder a las¬†clases y dem√°s elementos definidos en ello. Una de las ventajas de usar Namespaces es¬†**la rapidez y el ahorro de escritura de c√≥digo**, ya que evitamos escribir el Namespace completo dentro de nuestro c√≥digo. Por ejemplo¬†**con el¬†Namespace ‚ÄúSystem‚Äù podemos imprimir un mensaje as√≠ de sencillo**:

```cs
// Instanciamos el Namespace System con la directiva using:
using System;

// Imprimimos el siguiente Texto, con la sencilla instrucci√≥n:
Console.WriteLine("Ricos Postres !");

// Obtenemos:
Ricos Postres !

```

Pero si no usamos el Namespace System tendr√≠amos que escribir:

```cs
// Para acceder al Namespace System lo escribimos manualmente antes de la instrucci√≥n
// Console.WriteLine("Ricos¬†Postres¬†!");
System.Console.WriteLine("Ricos Postres !");

//¬†Obtenemos:
Ricos¬†Postres¬†!</pre>
```

Como pueden ver tendr√≠amos¬†que¬†estar declarando en cada linea el Namespace System. Entonces si usamos un Namespace evitaremos esto y tambi√©n podremos acceder a sus dem√°s propiedades. En este art√≠culo¬†les mostrar√© c√≥mo definir¬†y componer nuestro Namespace en un archivo aparte y luego lo usaremos o instanciaremos en un nuevo¬†archivo en¬†nuestro proyecto.

#### Definiendo¬†nuestro Namespace

Crearemos nuestro archivo¬†**postres.cs**¬†en donde definiremos nuestro Namespace llamado Postres:

```cs
//¬†Instanciamos¬†el¬†Namespace¬†System¬†con¬†la¬†directiva¬†using:
using System;

// Le doy un nombre a mi Namespace
namespace Postres
{
  // Creo la Clase MisPostres
  public class MisPostres

  {
    // Creo mi m√©todo Test
    public void Test()

    {
      // Imprimo un Texto
      Console.WriteLine("Soy el Namespace Postres !");

    }

  }

}
```

#### Utilizando el Namespace creado

Ahora vamos a usar nuestro Namespace, lo instanciaremos en nuestro archivo¬†**main.cs**:

```cs
// Instancio el Namespace Postres, ya no instancio el Namespace System porque ya viene dentro del
// Namespace Postres
using Postres;
// Creo un Namespace para mi Aplicaci√≥n, la llamare MiAplicacion
namespace MiAplicacion
{  
  // Creo la clase principal de mi Aplicaci√≥n
  class MainClass

  {
    // Declaro el M√©todo Main, dentro de el utilizar√© la clase Postres de el Namespace Postres que 
    // tengo en el archivo postres.cs
    public static void Main (string[] args)

    {     
      // Instancio la Clase MisPostres que defin√≠ dentro del Namespace Postre, dentro del archivo
      // postres.cs
      MisPostres mp = new MisPostres();

      // instancio el m√©todo Test que¬†defin√≠¬†dentro¬†del¬†Namespace¬†Postre,¬†dentro¬†del¬†archivo¬†postres.cs
      mp.Test();

    }

  }

}
```

Ejecutamos nuestro proyecto y obtendremos:

![Resultado](https://static.platzi.com/blog/uploads/2016/04/nar.jpg)

üé≤

## 7. Tipos de datos

|Tipo de dato |Espacio que ocupa en memoria |Rango |Descripci√≥n|
|-------------|-----------------------------|------|-----------|
|int          |4 bytes              |-2147483648 a 2147483647  |Almacena n√∫meros enteros                     |
|bool         |1 byte               |0 a 1                     |Almacena un valor que puede ser verdadero o falso|
|float        |4 bytes              |De 6 a 7 d√≠gitos          |Almacena n√∫meros decimales                   |
|double       |8 bytes              |Hasta 15 d√≠gitos          |Almacena n√∫meros decimales                   |
|char         |2 bytes              |Un solo car√°cter          |Almacena un √∫nico car√°cter o letra           |
|string       |2 bytes por car√°cter |-                         |Almacena una secuencia de caracteres         |
|long         |8 bytes              |-9223372036854775808 a 9223372 036 854 775 807|Almacena n√∫meros enteros |
|uint         |4 bytes              |0 a 4 294 967 295         |Almacena n√∫meros enteros positivos           |

[Mas tipos de datos](https://learn.microsoft.com/es-es/dotnet/csharp/language-reference/builtin-types/built-in-types)

### **Casteo impl√≠cito:**  
Consiste en transformar cierto tipo de dato en otro al momento de realizar una operaci√≥n, esto lo hace de manera autom√°tica c#.  
_Ejemplo: de un Int a un Long._

### **Casteo explicito:**  
Consiste en transformar un tipo de dato en otro de manera manual puesto que c# no lo hace de manera autom√°tica por el riesgo a la perdida de informaci√≥n .  
_Ejemplo: de un Double a un Float_

Para m√°s info sobre conversi√≥n de tipos de datos¬†[lee aqu√≠.](https://docs.microsoft.com/es-es/dotnet/csharp/programming-guide/types/casting-and-type-conversions)

‚ú® Importante conocer el espacio que ocupan en memoria cada tipo de dato, ya que as√≠ podemos hacer que nuestra aplicaci√≥n sea lo mas optima posible y no almacenar espacio innecesario

‚ùÑ En este video¬†[EL EXTRA√ëO Y TERRIBLE 2 147 483 647 ¬°¬°El n√∫mero que estuvo a punto de reventar Youtube!!](https://youtu.be/jrGWMaUOSvk)¬†se explica por que int (4 bytes = 2^32) llega justo a 2147483648 y como casi rompe Youtube, pues la variable que almacenaba las vistas era entero simple y un video estaba a punto de sobrepasarlo.

üé≤

## 8. Variables

üî• Crear nuevo proyecto:   
‚û° Aplicaci√≥n de consola ‚û° StringExample ‚û° .NET Core 3.1

```cs
using System;

namespace StringExample
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("What's your name? Please Write your full name?");
            string fullUserName = Console.ReadLine();

            Console.WriteLine("Hello " + fullUserName + ", Welcome to Platzi");
        }
    }
}
```

‚ñ∂ StringExample: Ver resultados en consola 

üî• Crear nuevo proyecto:   
‚û° Aplicaci√≥n de consola ‚û° NumericCalculator ‚û° .NET 6.0

```cs
// See https://aka.ms/new-console-template for more information
Console.WriteLine("Hello, World!");

int number1;
int number2;

Console.WriteLine("Input the first number");
number1 = Convert.ToInt32(Console.ReadLine());

Console.WriteLine("Input the second number");
number2 = Convert.ToInt32(Console.ReadLine());

int result = number1 * number2;
Console.WriteLine("The result is: " + result);
```

‚ñ∂ NumericCalculator: Ver resultados en consola 

### Nombrar Clases y Variables  
Com√∫nmente podemos encontrar formas distintas para escribir los nombres de nuestros programas, clases y variables. Estas son:

-   üêç**snake_case:**¬†S√≥lo usa min√∫sculas y separa las palabras con guion bajo ( _ ). Por consenso se usa en Python

-   üë¥**PascalCase:**¬†Cada inicial con may√∫scula y sin ning√∫n tipo de separaci√≥n entre palabras. El consenso indica que es la forma que usaremos para escribir los nombres de nuestros archivos, namespace (el nombre del programa y el namespace deben ser iguales tambi√©n por mero consenso) y clases

-   üê´**camelCase**: Primera inicial en min√∫scula y el resto en may√∫scula, sin separaci√≥n entre palabras. Esto lo usaremos para las variables (s√≠, nuevamente se trata de puro consenso).


De la mano con los puntos anteriores y por comodidad, sobre todo a la hora de trabajar en equipo, se recomienda que cada elemento (m√©todos, variables, funciones, etc.) de nuestro programa use¬†**nombres representativos**, es decir, que nombremos cada cosa de forma que se pueda entender sin dificultad qu√© deber√≠a representar o hacer, y siempre acompa√±ando con el tipo de dato que va a poseer la variable (en caso de tratarse de una)

```cs
int number1;
int number2;
```

üí°Recordemos que podemos usar a modo de comod√≠n la palabra reservada¬†_var_¬†en lugar del tipo de valor espec√≠fico a manejar, mas¬†**no es lo recomendado**:

```cs
var number1;
var number2;
```

**Casteos y ReadLine**  
Ahora, pueden darse casos en los que necesitemos hacer cambiar el tipo de dato que vamos a utilizar y que el sistema no lo est√© haciendo por su cuenta (**casteo impl√≠cito**,¬†_int -> long_¬†, por ejemplo), siendo necesario que nosotros realicemos el cambio de forma manual (**casteo expl√≠cito**, string -> int, por ejemplo). En estas situaciones C# posee un m√©todo para realizar esta tarea usando¬†_Convert_

```cs
int number1;
int number2;

Console.WriteLine("Input the first number");
number1 = Convert.ToInt32(Console.ReadLine());

Console.WriteLine("Input the second number");
number2 = Convert.ToInt32(Console.ReadLine());

int result = number1 * number2;
Console.WriteLine("The result is: " + result);
```

Con¬†_Convert_¬†iniciamos el proceso de cambio de tipo de variable, pasando del string (aplicado por C#), seguido del tipo de dato a seleccionar y su peso en bytes con¬†_ToInt32_¬†.

üí°Recordemos que¬†_Console.ReadLine()_¬†lo utilizamos para ingresar informaci√≥n, n√∫meros enteros en este caso, por nuestra terminal. Aqu√≠ estar√≠amos indicando que lo ingresado con¬†_Console.ReadLine()_¬†debe ser convertido a¬†_int_¬†mediante el m√©todo¬†_Convert_

```cs
Convert.ToInt32(Console.ReadLine());
```


### Tipos de conversi√≥n de datos en C#  
-   Conversi√≥n impl√≠cita
-   Conversi√≥n explicita
-   Conversi√≥n entre tipos no compatibles

#### Conversi√≥n impl√≠cita
La conversi√≥n impl√≠cita se da cuando convertimos un tipo de dato que ocupa un tama√±o menor en memoria a un que ocupa uno mayor por ejemplo:

```cs
byte b = 1;
int i = b;
```

En este ejemplo estamos convirtiendo un tipo de dato¬†**byte**¬†que ocupa un solo byte en memoria a un tipo de dato¬†**int**¬†que ocupa 4 bytes en memoria. Lo que ocurre internamente en memoria es:

```cs
b = 00000001
i = 00000000000000000000000000000001
```

La variable¬†**b**¬†esta compuesta de 7 ceros y un 1 y al convertir esta variable a un tipo de dato¬†**int**¬†C# a√±ade 24 ceros para completar los 4 bytes, por lo que no hay perdida de informaci√≥n.

En el caso contrario

#### Conversi√≥n explicita

```cs
int i = 1;
byte b = i;
```

Para realizar la conversi√≥n se necesitan eliminar 4 bytes de informaci√≥n por lo que C# no permite convertir los datos ya que podr√≠a haber una perdida de informaci√≥n. Para realizar esta conversi√≥n tenemos que expresar de forma explicita la conversi√≥n para decirle a C# que estamos seguros de realizarla. A esto se le conoce como casteo de datos. El casteo de datos en C# se hace de la siguiente forma:

```cs
int i = 1;
byte b = (byte)i;
```

#### Conversi√≥n entre tipos no compatibles
Pero que pasa si tratamos de castear datos que no son compatibles por ejemplo:

```cs
string s = "1";
int i = (int)s;
```

Esta instrucci√≥n no va a compilar por que los tipos nos son compatibles y el casteo no funciona. Esto se debe a que la forma en la que se guarda la informaci√≥n de cadena de texto y un n√∫mero son diferentes. Para realizar esta conversi√≥n podemos hacer uso de los m√©todos predefinidos como los siguientes:

```cs
string s = "1";
int i = Convert.ToInt32(s);
int j = int.Parse(s);
```

Todos los tipos de datos en C# poseen el m√©todo Parse que convierte una cadena de caracteres en su tipo de dato, en este caso¬†**int**. La clase¬†**Convert**¬†posee varios m√©todos para convertir una cadena de caracteres en varios tipos de datos:

-   ToByte()
-   ToInt16()
-   ToInt32()
-   ToInt64()

Los n√∫meros 16, 32 y 64 corresponden al n√∫mero se bits que son equivalentes a 2, 4 y 8 bytes.

üé≤

## 9. Manejo de strings
```cs
using System;

namespace helloWorldPlazi
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello Platzi!");

            int height = 170;
            int age = 26;
            string name = "Ale Vel";
            string information = "The requested info is: " 
	            + "\nUser name: " + name + "\nUser age: "
                + age+ "\nUser height: " + height;

            Console.WriteLine(information);
        }
    }
}
```

Tambien se puede interpolar el texto con¬†`$""`
[Documentaci√≥n]([https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated))

```cs
class Program 
	{ 
		static void Main(string[] args) 
		{ 
			Console.WriteLine("Hello Platzi!"); 
			
			int height = 170; 
			int age = 22; 
			string name = "Abdel Mejia"; 
			string information = $"The requested info is:\nUser name: {name} \nUser age: {age} \nUser height: {height}";
			 Console.WriteLine(information); 
		} 
	}
```

Con¬†`$` tambi√©n pueden hacer saltos de l√≠nea con`\t`

```cs
int height = 172; 
int age = 19; 
string name = "Marcos Lanuza"; 
string description = "The requested info is:\n" + 
	$"\tUser name = {name}\n" + 
	$"\tUser age = {age}\n" + 
	$"\tUser height = {height}"; 

Console.WriteLine(description);
```


‚ùÑ Hay diferentes funciones que se pueden usar con los strings.    
- **Length**¬†para contar el numero de caracteres de un string.  
- **ToUpper() y ToLower()**¬†para convertir todo el string en mayuscula o minuscula.  

El uso del \ es muy importante, ya que nos permite insertar en el string objetos como /, " y '.   
Ejemplos:

```cs
string team = "Liverpool";

Console.WriteLine("The length of the word Liverpool is: " + team.Length); //9 characters
Console.WriteLine(team.ToUpper()); //LIVERPOOL 
Console.WriteLine(team.ToLower()); //liverpool

Console.WriteLine("El \"Liverpool\""); //El "Liverpool"
Console.WriteLine("El \'Liverpool\'"); //El 'Liverpool'
Console.WriteLine("El \\Liverpool\\"); //El \Liverpool\
```

üé≤

## 10. Trabajando con n√∫meros y operadores aritm√©ticos   
Creamos nuevo proyecto ‚û° Console App (.NET Core)
Project name: **squareArea** ‚û° .NET Core 3.1

```cs
using System;

namespace squareArea
{
    internal class Program
    {
        static void Main(string[] args)
        {
            //Rectangle area calc.

            //Rectangle values
            float sideA = 10.2f; //füëàüëÄ
            int sideB = 1;
            sideB++;
            sideB++;
            sideB--;

            //Rectangle area formula is a*b
            float area = sideA * sideB;
			//float = float * int üëàüëÄ
            
            Console.WriteLine("The rectangle area is: " + area);
        }
    }
}
```

- Para comentar c√≥digo en una sola l√≠nea se escribe dos barras diagonales `//`.  
-   El doble slash sirve para comentar¬†**UNA**¬†l√≠nea pero no si queremos hacer saltos de l√≠nea. En este √∫ltimo caso lo haremos con `/* */`

Para la variables tipo flotante en C#, hay que agregarle una¬†**‚Äúf‚Äù**¬†al final de cada valor. Ejm:   
`float valor = 10.0f`

- Operador de Suma: `+`  
- Operador de Resta: `-`  
- Operador de Divisi√≥n: `/`  
- Operador de Multiplicaci√≥n: `*` 
- Operador para sacar M√≥dulo: `%`  
- Operador para incrementar: `++`  
- Operador para decrementar: `‚Äì-`

‚ú® Si escriben `cw` y dos veces tab les crea todo el `Console.WriteLine();`  
Y as√≠ evitan cansar sus manitas jajajaja üòä

üé≤

## 11. Operadores l√≥gicos

Creamos nuevo proyecto ‚û° Console App (.NET Core)
Project name: **LogicalOperatorsExample** ‚û° .NET 6.0

Ac√° no hay mucha variedad. Los operadores l√≥gicos dan como resultado¬†_True_¬†o¬†_False_¬†y se pueden dar mediante tres operaciones:

-   && -> AND : ‚Äú**ESTO Y AQUELLO**¬†se tienen que cumplir o morimos todos‚Äù
    
-   || -> OR : ‚ÄúSi¬†**ESTO**¬†o¬†**AQUELLO**¬†pasa, morimos todos‚Äù
    
-   ! -> NOT : ‚ÄúEsto¬†**NO ES AS√ç**, es todo lo contrario‚Äù
    

_"No entiendo, Maginer"_  
Ah√≠ vamos, Timmy. Vamos con un ejemplo en c√≥digo:

```cs
// See https://aka.ms/new-console-template for more information
Console.WriteLine("Hello, World!");

bool value1 = true;
bool value2 = true;
bool value3 = false;

// &&, ||, !

bool result = value1 && value2 && value3;
Console.WriteLine("The result of the logical AND is: " + result);
//Obtenemos: False

bool result2 = value1 || value2 || value3;
Console.WriteLine("The result of the logical OR is: " + result2);
//Obtenemos: True

bool result3 = !value1;
Console.WriteLine("The result of the logical ! is: " + result3);
//Obtenemos: False
```

Otro ejemplo:    
```cs
bool value1 = true; 
bool value2 = false; 
bool value3 = false; 
bool value4 = true; 

bool result1 = value1 && value2; 
Console.WriteLine(result1); 
// False 

bool result2 = value1 && value4; 
Console.WriteLine(result2); 
// True 

bool result3 = value1 || value4; 
Console.WriteLine(result2); 
// True 

bool result3 = !value2; 
Console.WriteLine(result3); 
// True
```

Seg√∫n la terminal¬†_result1_¬†dar√°¬†_False_. Por qu√©? Porque el operador¬†_&&_¬†**EXIGE**¬†que¬†**AMBOS**¬†resultados sean verdaderos, que¬†**TODAS**¬†las condiciones se cumplan (o morimos todos), mientras que¬†_||_¬†es m√°s permisivo y le basta con que¬†**UNA CONDICI√ìN SE CUMPLA**¬†(_result3_¬†=¬†_True_). Por su lado el operador¬†_NOT_, el¬†_!_, simplemente da el resultado opuesto (_value2_¬†es¬†_False_, as√≠ que¬†**NOT**¬†lo se√±ala como¬†_True_, algo as√≠ como ‚ÄúPuede ser que¬†_value2_¬†**NO SEA VERDADERO?**‚Äù y no, no es verdadero, as√≠ que¬†_True_).  
Un ejemplo pr√°ctico?

-   Si Timmy puso un mail v√°lido (_True_)¬†**YYYY**¬†un nick disponible (_True_) podr√° registrarse en Platzi (_True_)
    
-   Timmy se registr√≥ (_True_) pero¬†**NO**¬†confirm√≥ su mail (_False_), lo que es obligatorio (&&), as√≠ que no podr√° usar Platzi (_False_)
    
-   Si a Timmy le regalan el plan Expert¬†**OOO**¬†lo adquiere √©l, podr√° ver todos los cursos de Platzi. Timmy no lo pag√≥ (_False_) pero se lo regalaron (_True_), asi que puede usar Platzi al completo (_True_)
    
-   Timmy¬†**NO ES**¬†una referencia a los Simpsons?¬†_False_. Entonces s√≠ es una referencia a los Simpsons (_True_)


‚ú® Pueden definir multiples variables en la misma l√≠nea as√≠:

```cs
var (a, b, c) = (false, true, false);
```

![Operadores l√≥gicos](https://i.postimg.cc/yNFmKXgb/11-logicos-relacionales.jpg)

Ver todos los operadores üëâ[[js-basico#11 Operadores Asignaci√≥n Comparaci√≥n y Aritm√©ticos]] üü£ Estos enlaces solo funcionan en obsidian. 

üé≤

## 12. Operadores relacionales

```cs
/*
 == Igual a
 != No igual a 
 >  Mayor que
 <  Menor que 
 >= Mayor o igual que
 <= Menor o igual que
*/

int value1 = 3;
int value2 = 18;
int value3 = -18;

bool result0 = value1 == value2;
Console.WriteLine("The result of value1 == value2 is: " + result0);

bool result1 = value1 != value2;
Console.WriteLine("The result of value1 != value2 is: " + result1);

bool result2 = value1 > value2;
Console.WriteLine("The result of value1 > value2 is: " + result2);

bool result3 = value1 < value2;
Console.WriteLine("The result of value1 < value2 is: " + result3);

bool result4 = value1 >= value2;
Console.WriteLine("The result of value1 >= value2 is: " + result4);

bool result5 = value1 <= value2;
Console.WriteLine("The result of value1 <= value2 is: " + result5);
```

![Documentaci√≥n](https://learn.microsoft.com/es-es/dotnet/csharp/language-reference/operators/comparison-operators)

üé≤

## 13. C√≥mo leer datos de un usuario en C#
```cs
using System;

namespace squareArea
{
    internal class Program
    {
        static void Main(string[] args)
        {
            //Rectangle area calc.

            //Rectangle values
            Console.WriteLine("Please enter the side A of the rectangle, you can use decimals");
            float sideA = float.Parse(Console.ReadLine());

            Console.WriteLine("Please enter the side B of the rectangle, you can use decimals");
            float sideB = float.Parse(Console.ReadLine());

            //Rectangle area formula is a*b
            float area = sideA * sideB;

            Console.WriteLine("The rectangle area is: " + area);
        }
    }
}
```

Durante la clase vimos dos tipos de conversi√≥n, pero ü§î, ¬øCu√°l es la diferencia entre ambas?  

ü•ä¬†**Convert VS. Parse**¬†ü•ä

-   Ambas se pueden usar para convertir datos de un tipo a otro.
-   Convert puede manejar valores NULL retornando un 0.
-   Parse no puede manejar valores NULL y muestra un error (ArgumentNullException).  

‚úÖ Ejemplo:  

> En la variable number2 convertiremos un valor NULL en FLOAT, como sabemos nos retornara 0, por ende, el resultado de la operaci√≥n es igual a 0.  
> üòâ Puedes comprobar lo que retorna Convert imprimi√©ndolo por pantalla.

```cs
float number1 = 10.555f;
float number2 = Convert.ToSingle(null);
float result = number1 * number2;

Console.WriteLine($"El resultado es igual a {result}"); 
```

Dato: Para usar Convert para un tipo de dato FLOAT puede realizarse atreves del m√©todo `.ToSingle()`  

> Trataremos de realizar la misma conversi√≥n, pero ahora usando Parse. Cuando ejecutemos nos mostrara un error ü•≤.


![](https://i.postimg.cc/JzzhLjDx/error.png)

üé≤

## 14. Arreglos en C#
Creamos nuevo proyecto ‚û° Console App (.NET Core)
Project name: **ArrayDemoProject** ‚û° .NET 6.0

```cs
// See https://aka.ms/new-console-template for more information
Console.WriteLine("Hello, World!");

string[] coffeTypes;
float[] coffePrices;

coffeTypes = new string[] { "Expreso", "Largo", "Filtrado", "Latte" };
coffePrices = new float[] { 1.2f, 1.5f, 5.0f, 5.5f };

coffeTypes[1] = "Lungo";

for (int i = 0; i < coffeTypes.Length; i++)
{
    Console.WriteLine(coffeTypes[i] + " Coffe $ " + coffePrices[i]);
}
```

üî• Formas de definir un Array o Matrices

- Sin especificar n√∫mero de espacios.   
	`int[] array1;`

- Declarando numero de espacios, se inicializa el array con el numero de espacios mediante new.   
	`int[] array2 = new int[5];`

- Numero de espacios y valores, establecemos el numero de espacios y el valor de cada uno en la misma declaraci√≥n.
	`int[] array3 = new int[3] { 3, 5, 10};`

- Sin especificar numero de espacios, el numero de espacios del array de define mediante el numero de valores en la declaraci√≥n.
	`int[] array4 = { 4, 9, 5, 1 };`

Siendo este ultimo el que se muestra en la clase

üî• Importante recordar, los arreglos tienen un length, que es el tama√±o real de tu arreglo, por ejemplo:

```cs
string[] coffeTypes = new string[4];
```

En este caso tenemos un arreglo de tama√±o 4, lo que significa que el √∫ltimo dato en este arreglo ser√° el √≠ndice 3.¬øPor qu√©?  
Porque los arreglos comienzan desde √≠ndice 0, hasta el length - 1. en este caso, 3.

Por lo tanto si yo hago un ciclo cualquiera, como un for, debo hacerlo hasta el tama√±o del arreglo < 1, es decir, el t√©rmino del ciclo debe ser cuando tengo un valor igual al length o mayor.

Por ejemplo:

```cs
for(int i = 0 ; i < 4 ; i++){}
```

Tambi√©n importante recordar que los arreglos tienen integrados de manera impl√≠cita el length que tienen, por esto es que tambi√©n funciona lo siguiente:

```cs
for(int i = 0 ; i < coffeTypes.Length ; i++){}
```

[Documentaci√≥n](https://learn.microsoft.com/es-es/dotnet/csharp/programming-guide/arrays/)

üé≤

## 15. Listas
Creamos nuevo proyecto ‚û° Console App (.NET Core)
Project name: **ListExampleProject** ‚û° .NET 6.0

```cs
// See https://aka.ms/new-console-template for more information
Console.WriteLine("Hello, World!");

List<string> tacoShoppingList = new List<string>();

tacoShoppingList.Add("Five Tacos de suadero");
tacoShoppingList.Add("Four Tacos de Tripa");
tacoShoppingList.Add("Five Tacos de pastor");
tacoShoppingList.Add("Four Coca-Colas\n");

for (int i = 0; i < tacoShoppingList.Count; i++)
{
    Console.WriteLine(tacoShoppingList[i]);
}

tacoShoppingList.RemoveAt(0);
//tacoShoppingList.Remove("Five Tacos de suadero");

for (int i = 0; i < tacoShoppingList.Count; i++)
{
    Console.WriteLine(tacoShoppingList[i]);
}
```

üé≤

## 16. M√©todos o methods
Un m√©todo es un bloque de c√≥digo que contiene una serie de instrucciones. Un programa hace que se ejecuten las instrucciones al llamar al m√©todo y especificando los argumentos de m√©todo necesarios. En C#, todas las instrucciones ejecutadas se realizan en el contexto de un m√©todo. El m√©todo¬†`Main`¬†es el punto de entrada para cada aplicaci√≥n de C# y se llama mediante Common Language Runtime (CLR) cuando se inicia el programa.


```cs
using System;

namespace methods
{
    internal class Program
    {
        static void Main(string[] args)
        {
            float[] pricesArray;

            pricesArray = new float[10];
            pricesArray[0] = 1.5f;
            pricesArray[1] = 2.5f;
            pricesArray[3] = 3f;
            pricesArray[4] = 5f;
            
            Random rnd = new Random();
            Console.WriteLine("Hello World, of random numbers!");
            Console.WriteLine($"{rnd.Next(1, 10)}");
        }
    }
}
```

[Documentaci√≥n sobre Random Class](https://learn.microsoft.com/en-us/dotnet/api/system.random?view=net-6.0)

üî• Una peque√±a aclaraci√≥n de conceptos que les evitar√° confusiones en un futuro.

```cs
Random rnd = new Random();

Console.WriteLine($"Una valor random: {rnd.Next(1,10)}");
```

-   `rnd`¬†es una instancia de la clase¬†`Random()`, esta instancia tendr√° todos los m√©todos y propiedades de la clase.
-   `Next()`¬†es un m√©todo de la clase¬†`Random()`, como¬†`rnd`¬†es una instancia de la clase¬†`Random()`, puede hacer uso de todos sus m√©todos y propiedades ‚Äúpublicas‚Äù.

[Documentaci√≥n sobre los metodos](https://learn.microsoft.com/es-es/dotnet/csharp/methods)

M√©todos y argumentos: ¬øCu√°les son los m√©todos mas utilizados en C#?

üé≤

## 17. M√©todos de strings
Bienvenida o bienvenido a esta clase donde profundizaremos en los m√©todos de C#, espec√≠ficamente en los m√©todos de strings.

### Los m√©todos en C#

Un¬†**m√©todo**¬†es un bloque de c√≥digo que contiene varias instrucciones que podemos ejecutar las veces que necesitemos. Son de gran ayuda cuando tienes que hacer lo mismo varias veces en un mismo programa para no repetir el mismo c√≥digo una y otra vez.

En la clase anterior conocimos c√≥mo invocar un m√©todo y utilizarlo cuantas veces necesitemos para realizar acciones espec√≠ficas en nuestro programa. Ahora veamos algunos de estos m√©todos para el manejo de strings.

### M√©todos de strings

```cs
using System;
					
public class Program
{
	public static void Main()
	{
		string ClassTopic = "M√©todos de strings";
		string School = "Platzi";
		Console.WriteLine("Estoy aprendiendo de "+ ClassTopic + " en " + School + ".");
	}
}
```

En la pieza de c√≥digo anterior puedes ver un peque√±o programa con dos variables tipo string y su impresi√≥n. Para este tipo de variables podemos usar una gran cantidad de m√©todos predefinidos dentro de la biblioteca est√°ndar de C#.

Utilicemos estas dos variables strings para conocer algunos de ellos.

#### Clone()

```cs
	string SchoolClone = School.Clone().ToString();
	Console.WriteLine(SchoolClone);
```

El m√©todo¬†`Clone()`¬†crea un clon exacto de un string en una variable de tipo objeto. Por ello es necesario convertirlo a string utilizando¬†`ToString()`.

#### CompareTo()

```cs
Console.WriteLine(ClassTopic.CompareTo(School));
Console.WriteLine(School.CompareTo(SchoolClone));
```

Sirve para comparar el contenido de dos strings. Si son iguales devuelve 0 para true y si son diferentes retorna 1 para false. En este caso como¬†`School`¬†y¬†`SchoolClone`¬†son strings id√©nticos devolver√° un 0. ¬øQu√© crees que se imprima en la primera l√≠nea?

#### Contains()

```cs
Console.WriteLine(School.Contains("Pla"));
```

Retorna¬†`True`¬†si el string contiene los caracteres que se pongan en los argumentos del m√©todo.

#### EndsWith()

```cs
Console.WriteLine(School.EndsWith("zi"));
```

Similar a¬†`Contains()`, pero para comparar si los caracteres est√°n al final del string.

#### StartsWith()

```cs
Console.WriteLine(School.StartsWith("Pl"));
```

Funciona de la misma manera que¬†`EndsWith()`, pero en este caso comprueba si empieza con una serie de caracteres indicados.

#### Equals()

```cs
Console.WriteLine(School.Equals(SchoolClone));
```

Funciona de forma parecida a¬†`CompareTo()`, pero para indicar si el contenido de ambos strings retorna¬†`True`¬†o¬†`False`.

#### IndexOf()

```cs
Console.WriteLine(School.IndexOf("a"));
```

Regresa la posici√≥n dentro del string del car√°cter indicado en el argumento.

#### ToLower() y ToUpper()

```cs
Console.WriteLine(ClassTopic.ToLower());
Console.WriteLine(ClassTopic.ToUpper());
```

Convierten el string en todas letras min√∫sculas o may√∫sculas.

#### Insert()

```cs
Console.WriteLine(School.Insert(6, " es educaci√≥n online efectiva"));	
```

Inserta un nuevo string dentro de otro en la posici√≥n indicada dentro de los argumentos. En este caso es en 6 que es la posici√≥n despu√©s de la √∫ltima letra de ‚ÄúPlatzi‚Äù.

#### LastIndexOf()

```cs
Console.WriteLine(ClassTopic.LastIndexOf("s"));
```

Regresa la posici√≥n de la √∫ltima vez que aparece el car√°cter. En este caso la letra ‚Äús‚Äù aparece varias veces en el string y as√≠ podemos notar c√≥mo devuelve la √∫ltima posici√≥n en la que aparece.

#### Remove()

```cs
Console.WriteLine(ClassTopic.Remove(6));
```

Elimina los caracteres del string a partir de la posici√≥n que le indiquemos hasta el final.

#### Replace()

```cs
Console.WriteLine(ClassTopic.Replace("s", "z"));
```

Reemplaza todos los caracteres por otro indicado. En este caso todas las ‚Äús‚Äù ser√°n cambiadas por ‚Äúz‚Äù.

#### Split()

```cs
string[] split = ClassTopic.Split(new char[] { 's' });		
		
        Console.WriteLine(split[0]);
        Console.WriteLine(split[1]);
        Console.WriteLine(split[2]);
```

Este es un caso especial donde creamos un nuevo string donde guardamos el string separado en trozos por la letra indicada en los argumentos del m√©todo. Para este caso se separa por la letra ‚Äús‚Äù en 3 trozos que son los que imprimimos.

#### Substring()

```cs
Console.WriteLine(ClassTopic.Substring(2,10));
```

Devuelve un substring o trozo de string de acuerdo a las posiciones indicadas en los argumentos.

#### ToCharArray()

```cs
School.ToCharArray();
```

Convierte el string en un arreglo de caracteres.

#### Trim()

```cs
string TextWithSpaces = "  hola, hab√≠a espacios al principio y al final ";
Console.WriteLine(TextWithSpaces.Trim());

```

Elimina espacios al principio y al final de un string.

### Tu reto

Ya conoces varios de los m√©todos que puedes utilizar con strings. Estos son los m√°s comunes, pero existen unos m√°s.

Como reto de esta clase crea un programa donde emplees por lo menos 5 de estos m√©todos de strings o de alg√∫n otro que investigues. Pon a volar tu creatividad y comparte en los comentarios el programa que creaste.

---

Te veo en la pr√≥xima donde obtendr√°s el superpoder de crear tus propios m√©todos y utilizarlos cuando los necesites.

üé≤

## 18. C√≥mo crear tus propios m√©todos
Ha llegado el momento de aprender a crear tus propios m√©todos para tus programas en C#. Una vez que domines esta habilidad no querr√°s dejarla por lo poderosa que puede ser.

### Creando nuestro m√©todo

Lo primero que debemos hacer es iniciar un nuevo proyecto con nuestra clase base, tal cual, lo hemos hecho hasta ahora. Nombra tu proyecto¬†`MyMethods`¬†y tendr√°s un c√≥digo como este:

```cs
using System;

public class MyMethods
{
	public static void Main()
	{
		Console.WriteLine("Hello World");
	}
}
```

Arriba del m√©todo¬†`Main()`¬†crea tu primer m√©todo siguiendo una estructura similar de la siguiente manera:

```cs
	public void IntegerAddition(int a, int b)
	{
		int Addition = a + b;
		Console.WriteLine("El resultado es " + Addition);
	}
```

Este m√©todo tiene el objetivo de sumar dos n√∫meros enteros. Para ello dentro de los par√©ntesis se incluyeron dos par√°metros que son los dos n√∫meros a sumar.

Dentro del cuerpo o bloque del m√©todo hay dos instrucciones. La primera¬†`int Addition = a + b;`¬†es donde se realiza la operaci√≥n de suma, asign√°ndose a una variable del mismo tipo, y en la siguiente imprimimos ese resultado.

### Accediendo al m√©todo

Para utilizar nuestro m√©todo debemos llamarlo y lo haremos desde nuestro m√©todo¬†`Main()`.

```cs
	public static void Main()
	{
		// Aqu√≠ llamaremos al m√©todo
	}

```

Es necesario generar una referencia creando una instancia de nuestra clase donde se ejecuta el programa. Para ello escribe:

```cs
MyMethods MyProgram = new MyMethods();
```

Donde¬†`MyMethods`¬†es la clase del programa y¬†`MyProgram`¬†el nombre que se le da a la instancia que se crea y que se usar√° como referencia para ejecutar el m√©todo las veces que sea necesario como se ve a continuaci√≥n:

```cs
MyProgram.IntegerAddition(3,6);
```

Esta l√≠nea probablemente te parece m√°s parecida a lo que has visto con los m√©todos que hemos utilizado antes. Lo que hace es llamar a la instancia¬†`MyProgram`¬†y a su m√©todo¬†`IntegerAddition()`¬†que es el que creamos. Dentro de sus par√©ntesis se ponen los argumentos que necesitan los par√°metros¬†`int a`¬†e¬†`int b`¬†que se le asignaron.

```cs
	public static void Main()
	{
		MyMethods MyProgram = new MyMethods();
		MyProgram.IntegerAddition(3,6);
	}

```

### M√©todos que retornan un valor

Algo que quiz√° no notaste es que el m√©todo anterior ten√≠a una palabra clave ‚Äúvoid‚Äù, lo que significa que no retorna alg√∫n valor. Es por ello que dentro del mismo m√©todo se imprimi√≥ el resultado.

Para generar m√©todos de los que podamos obtener valores conocer√°s la palabra clave¬†`return`¬†y al momento de crear un m√©todo se le pondr√° el tipo de dato que retornar√° en lugar de¬†`void`:

```cs
	public int IntegerMultiplication(int a, int b)
	{
		int Multiplication = a * b;
		return Multiplication;
	}

```

Este es un m√©todo muy similar al anterior con la diferencia de que tiene un valor¬†`int`¬†a ser retornado.

Al final de todo el contenido del m√©todo se encuentra la instrucci√≥n¬†`return Multiplication;`¬†que indica, con la palabra clave¬†`return`¬†que regresar√° el valor que hay dentro de esa variable al punto donde se llame el m√©todo desde¬†`Main()`.

```cs
public static void Main()
	{
		int result = MyProgram.IntegerMultiplication(12,2);	
		Console.WriteLine("El resultado de la multiplicaci√≥n es " + result);
	}
```

En este caso, como el m√©todo regresa un valor, es necesario almacenarlo en una variable. Al imprimir ese resultado se ver√° c√≥mo el m√©todo funciona correctamente ejecutando la multiplicaci√≥n.

```cs
using System;

public class MyMethods //üëàüëÄ Program
{
	//Method 1
	public void IntegerAddition(int a, int b)
	{
		int Addition = a + b;
		Console.WriteLine("El resultado es " + Addition);
	}

	//Method 2
	public int IntegerMultiplication(int a, int b)
	{
		int Multiplication = a * b;
		return Multiplication;
	}
	
	public static void Main()
	{
		//Access reference
		MyMethods MyProgram = new MyMethods();
		
		//Call method 1
		MyProgram.IntegerAddition(3,6);

		//Call method 2
		int result = MyProgram.IntegerMultiplication(12,2);	
		Console.WriteLine("El resultado de la multiplicaci√≥n es " + result);		
	}
}
```

---

Ahora conoces c√≥mo crear y utilizar tus propios m√©todos. Como reto de esta clase crea un m√©todo que ejecute la divisi√≥n de dos n√∫meros. Como tip toma en cuenta que la mayor√≠a de las divisiones no dan resultados enteros, por lo que necesitar√°s definir tu m√©todo y variables con otro tipo de dato.

Comparte tu resultado en el sistema de comentarios. ¬°Nos vemos en la pr√≥xima clase!

#### ‚ùÑ Ejemplo: 
```cs
using System; 
namespace Mis_metodos 
{ 
	class MisMetodos 
	{ 
		public float division(float a,float b) 
		{ 
			float operacion = a / b; 
			return operacion; 
		} 
		public static void Main() 
		{ 
			MisMetodos metodo = new MisMetodos(); 
			float imprimir= metodo.division(10, 2);
			Console.WriteLine(imprimir); 
		} 
	} 
}
```

üé≤

## 19. La sentencia if
Creamos nuevo proyecto ‚û° Console App (.NET Core)
Project name: **ifStatement** ‚û° .NET Core 3.1

```cs
using System;

namespace ifStatement
{
    internal class Program
    {
        static void Main(string[] args)
        {
            int anyValue = 14;
            string message = "";

            if (anyValue == 7)
            {
                message = "OMG, it's a miracle any Value is 7\n";
            }
            else if (anyValue == 14)
            {
                message = "OMG, it's a double miracle the value is 14\n";
            }
            else
            {
                message = "Puff, the value wasn't 7";
            }

            Console.WriteLine($"The answer is: {message}");
        }
    }
}
```

### Otro ejemplo: 
```cs
using System;
using System.Collections.Generic;

namespace ifFood
{
    internal class Program
    {
        static void Main(string[] args)
        {
            string name;
            string message = "";
            int food;

            Console.WriteLine("Escriba su nombre: ");
            name = Console.ReadLine();
            Console.WriteLine("\nHola " + name + ", tenemos estos deliciosos platillos:\n");

            List<string> PeruvianFood = new List<string>();
            PeruvianFood.Add("1. Lomo saltado");
            PeruvianFood.Add("2. Arroz con pollo");
            PeruvianFood.Add("3. Ceviche");
            PeruvianFood.Add("4. Caviar");

            for (int i = 0; i < PeruvianFood.Count; i++)
            {
                Console.WriteLine(PeruvianFood[i]); 
            }

            Console.WriteLine("\nEscribe el n√∫mero de su comida preferida: ");
            food = Convert.ToInt32(Console.ReadLine());

            if (food >= 1 && food <= 4)
            {
                message = $"\nSu platillo {PeruvianFood[food-1]} est√° listo para ser enviado";
            }else
            {
                message = "No existe la comida que pidio";
            }
            Console.WriteLine(message);
        }
    }
}
```

[Documentaci√≥n Operadores de comparaci√≥n](https://learn.microsoft.com/es-es/dotnet/csharp/language-reference/operators/comparison-operators)

üé≤

## 20. La sentencia switch
Hola, quiero felicitarte por haber llegado hasta aqu√≠. Estamos casi por llegar al final de este curso y en este momento conocer√°s la sentencia Switch.

### ¬øPara qu√© sirve Switch?

Piensa en ella como una alternativa a¬†`if-else`, pero en este caso se evaluar√° que una sola expresi√≥n coincida con una cantidad limitada de valores o condiciones.

Imagina que tienes una lista limitada de refrescos y quieres imprimir en un ticket cu√°l escogi√≥ el cliente y su precio. Para este caso podemos utilizar un Switch case de esta forma:

```cs
using System;
					
public class switchExample
{
	public static void Main()
	{
		Console.WriteLine("Enter the selected soda: ");
		string caseSwitch = Console.ReadLine();

		switch (caseSwitch)
		{
          case "cola":
              Console.WriteLine("Cola soda - $2 USD");
              break;
          case "lime":
              Console.WriteLine("Lime soda - $1 USD");
              break;
          case "orange":
              Console.WriteLine("Orange soda - $1.5 USD");
              break;
		  case "apple":
			  Console.WriteLine("Apple soda - $1 USD");
              break;
          default:
              Console.WriteLine("ERROR: You did not select a soda or you entered an incorrect value.");
              break;
		}
	}
}
```

### C√≥mo funciona

Para este ejemplo tenemos cuatro casos que el usuario puede elegir y una variable es la que es evaluada para que el Switch decida qu√© bloque de c√≥digo ejecutar dependiendo de cada caso.

En el ejemplo esta variable es¬†`caseSwitch`¬†y es en¬†`switch(caseSwitch)`¬†donde se le indica a la sentencia Switch qu√© variable debe comparar para su decisi√≥n.

As√≠ es que si la variable es igual a¬†`‚Äúcola‚Äù`, por ejemplo, el case har√° match y ejecutar√°:

```cs
Console.WriteLine("Cola soda - $2 USD");
break;
```

Si te fijas hay algo muy importante al final de cada bloque dentro de los casos y es la palabra reservada¬†`break`.

Esta palabra le indica al programa que es el punto donde terminan todas las instrucciones de ese¬†`case`termina toda instrucci√≥n de ese caso para regresar al punto de ejecuci√≥n siguiente fuera del switch para continuar con el programa.

### ¬øY qu√© hay de default?

Al final de toda la estructura de Switch es muy recomendable poner un caso default. Piensa en √©l como un¬†`else`¬†que incluye algo que el programa debe ejecutar en caso de que no haya match con ninguno de los casos.

```cs
default:
    Console.WriteLine("ERROR: You did not select a soda or you entered an incorrect value.");
    break;
```

Para este ejemplo se imprime que al no haber ingresado alguno de los valores de los casos se est√° cayendo en un error. Un caso de uso bastante utilizado para los defaults.

---

En esta clase aprendiste otra sentencia del mundo de C# que ya puedes empezar a poner en pr√°ctica en tus programas. ¬°Te veo en la pr√≥xima clase porque es momento de conocer sobre los ciclos!

üé≤

## 21. Ciclo for
Creamos nuevo proyecto ‚û° Console App (.NET Core)
Project name: **forCicle** ‚û° .NET Core 3.1

```cs
using System;
//Los ciclos FOR ejecutan una instrucci√≥n 
//o varias, cada vez que ejecuta un ciclso
namespace forCicle
{
    internal class Program
    {
        static void Main(string[] args)
        {
            for (int i = 0; i <= 50; i+=10)
            {
                Console.WriteLine("Hello World! #{0}", i);
            }
        }
    }
}
```


Un ciclo for puede tener una o mas variables de control

```cs
for (int i = 0, j = 0; i < 10 && j > -10; i++, j--)
    {
        Console.WriteLine("i: "+i+" j: "+j);
    }
```

üé≤

## 22. Ciclo while
Creamos nuevo proyecto ‚û° Console App (.NET Core)
Project name: **whileDoWhile** ‚û° .NET Core 3.1

### While
```cs
using System;
using System.Runtime.CompilerServices;

namespace whileDoWhile
{
    internal class Program
    {
        static void Main(string[] args)
        {
            bool continueSoftwareExecution = true;

            while(continueSoftwareExecution == true)
            {
                Console.WriteLine("Do you wish to keep the software running? write 1 if yes, 0 if no");

                int keepGoing = Convert.ToInt16(Console.ReadLine());
                if (keepGoing == 1)
                {
                    Console.WriteLine("Hello World! The software will keep running");
                    continueSoftwareExecution = true;
                }else if (keepGoing == 0)
                {
                    Console.WriteLine("This is the last time the software is running");
                    continueSoftwareExecution = false;
                }
                else
                {
                    Console.WriteLine("Invalid input, Try Again");
                }  
            }
        }
    }
}
```

### Do While  
```cs
using System;
using System.Runtime.CompilerServices;

namespace whileDoWhile
{
    internal class Program
    {
        static void Main(string[] args)
        {
            bool continueSoftwareExecution = false;

            do
            {
                Console.WriteLine("Do you wish to keep the software running? write 1 if yes, 0 if no");

                int keepGoing = Convert.ToInt16(Console.ReadLine());
                
                if (keepGoing == 1)
                {
                    Console.WriteLine("Hello World! The software will keep running");
                    continueSoftwareExecution = true;
                }
                else if (keepGoing == 0)
                {
                    Console.WriteLine("This is the last time the software is running");
                    continueSoftwareExecution = false;
                }
                else
                {
                    Console.WriteLine("Invalid input, Try Again");
                }
            } while (continueSoftwareExecution == true);
        }
    }
}
```

#### for, while, do-while
üî• Grosso modo  

- **for**    
	Se utilizar√° cuando se conozca la cantidad de veces que se va a repetir nuestro bloque de c√≥digo.

- **while**    
	Es conveniente utilizarlo cuando la cantidad de veces a repetir el ciclo dependa de un factor dif√≠cil de controlar o que llegar√° en un momento inesperado.

- **do-while**   
	Lo emplearemos para asegurar que nuestro ciclo se ejecute al menos una vez y que adem√°s las condiciones del problema sean similares a las de los problemas en las que se emplea¬†**while**

üé≤

## 23. Introducci√≥n del proyecto: sistema de registros de usuarios
Creamos nuevo proyecto ‚û° Console App (.NET Core)
Project name: **restaurant10TablesReservationSystem** ‚û° .NET Core 3.1

### Primera parte: 
```cs
using System;

/*
 * 1. Validar si es usuario existente o si se debe registrar y generar un sistema de registros o login
 * 2. El programa debe ser capaz de darle la bienvenida a un usuario existente
 * 3. El programa debe repetirse hasta que se registren los 10 comensales 
 */

namespace restaurant10TablesReservationSystem
{
    internal class Program
    {
        static void Main(string[] args)
        {
            string[] userNames = new string[10] { "migue", "", "", "", "", "", "", "", "", "" };
            int arrayCurrentIndex = 1;
            bool userType;

            Console.WriteLine("Welcome to the best restaurant in the world!");

            while (true)
            {
                Console.WriteLine("Are you registered user? Write true; or write false to register");
                userType = Convert.ToBoolean(Console.ReadLine());

                if (userType == true)
                {
                    Console.WriteLine("Hello, you are a registered user, please enter your user name");
                    string userToSearch = Console.ReadLine();
                    Console.WriteLine("The user you searched is {0}", userToSearch);
                }
            }
        }
    }
}
```

üé≤

## 24. Creando la b√∫squeda y el registro de usuarios

```cs
using System;

/*
 * 1. Validar si es usuario existente o si se debe registrar y generar un sistema de registros o login
 * 2. El programa debe ser capaz de darle la bienvenida a un usuario existente
 * 3. El programa debe repetirse hasta que se registren los 10 comensales 
 */

namespace restaurant10TablesReservationSystem
{
    internal class Program
    {
        static void Main(string[] args)
        {
            string[] userNames = new string[10] { "migue", "", "", "", "", "", "", "", "", "" };
            int arrayCurrentIndex = 1;
            bool userType;

            Console.WriteLine("Welcome to the best restaurant in the world!");

            while (true)
            {
                if (arrayCurrentIndex == 10)
                {
                    Console.WriteLine("The restaurant is full, try again next year");
                    //Termina el programa
                    Environment.Exit(0); //üëàüëÄ   
                }
                Console.WriteLine("\nAre you registered user? Write true or write false to register");
                userType = Convert.ToBoolean(Console.ReadLine());

                if (userType == true)
                {
                    Console.WriteLine("Hello, you are a registered user, please enter your user name");
                    string userToSearch = Console.ReadLine();
                    Console.WriteLine("The user you searched is {0}", userToSearch);

                    //IndexOF(parameters):üëàüëÄ
                    //userNames: Lista en la que va a buscar 
                    //UserToSearch: Es lo que va a buscar
                    int index = Array.IndexOf(userNames, userToSearch);

                    if (index == -1) //No lo encontr√≥ y arroja -1
                    {
                        Console.WriteLine("User not found, try again or register");
                    }
                    else
                    {
                        Console.WriteLine("Welcome {0}, it's a pleasure to give you food", userNames[index]);
                    }
                }else if (userType == false)
                {
                    Console.WriteLine("Please write and remember your User Name");
                    userNames[arrayCurrentIndex] = Console.ReadLine();
                    Console.WriteLine("Your User has been saved successfully\n" +
                        "Your User Name is {0}", userNames[arrayCurrentIndex]);
                    arrayCurrentIndex++;
                }
            }
        }
    }
}
```

### IndexOF
Informa el √≠ndice de base cero de la primera aparici√≥n de un car√°cter o cadena Unicode especificado dentro de esta instancia.¬†El m√©todo devuelve -1 si el car√°cter o la cadena no se encuentra en esta instancia.

[Documentaci√≥n](https://learn.microsoft.com/en-us/dotnet/api/system.string.indexof?view=net-6.0)

### Environment.Exit(0)
Finaliza este proceso y devuelve un c√≥digo de salida al sistema operativo. Use 0 (cero) para indicar que el proceso se complet√≥ con √©xito.

[Documentaci√≥n](https://learn.microsoft.com/en-us/dotnet/api/system.environment.exit?view=net-6.0)

üé≤

## 25. Finalizado del proyecto: mostrando la lista de usuarios registrados

```cs
using System;

/*
 * 1. Validar si es usuario existente o si se debe registrar y generar un sistema de registros o login
 * 2. El programa debe ser capaz de darle la bienvenida a un usuario existente
 * 3. El programa debe repetirse hasta que se registren los 10 comensales 
 */

namespace restaurant10TablesReservationSystem
{
    internal class Program
    {
        static void Main(string[] args)
        {
            string[] userNames = new string[10] { "Pedro", "Robert", "Selena", "Mike", "Dani", "Platz", "i", "Celis", "Joan", "" };
            int arrayCurrentIndex = 9; //Nos va a indicar la posici√≥n
            bool userType;

            Console.WriteLine("Welcome to the best restaurant in the world!");

            while (arrayCurrentIndex < 10)
            {
                Console.WriteLine("\nAre you registered user? Write true or write false to register");
                userType = Convert.ToBoolean(Console.ReadLine());
                
                if (userType == true)
                {
                    Console.WriteLine("Hello, you are a registered user, please enter your user name");
                    string userToSearch = Console.ReadLine();
                    Console.WriteLine("The user you searched is {0}", userToSearch);

                    //IndexOF: 
                    //userNames: Lista en la que va a buscar 
                    //UserToSearch: Es lo que vamos a buscar
                    int index = Array.IndexOf(userNames, userToSearch);

                    if (index == -1) //No lo encontr√≥ y arroja -1
                    {
                        Console.WriteLine("User not found, try again or register");
                    }
                    else
                    {
                        Console.WriteLine("Welcome {0}, it's a pleasure to give you food", userNames[index]);
                    }
                }else if (userType == false)
                {
                    Console.WriteLine("Please write and remember your User Name");
                    userNames[arrayCurrentIndex] = Console.ReadLine();
                    Console.WriteLine("Your User has been saved successfully\n" +
                        "Your User Name is {0}", userNames[arrayCurrentIndex]);
                    arrayCurrentIndex++;
                }
            }

            Console.WriteLine("The restaurant is full, try again next year\n These are the guests to the dinner: ");

            int auxIndex = 0;

            foreach (string element in userNames)
            {
                Console.WriteLine("User number {0} and user name: {1}", auxIndex+1, userNames[auxIndex]);
                auxIndex++;
            }

            //Finaliza el programa
            Environment.Exit(0); //üëàüëÄ  
        }
    }
}
```

üî• Control + K + C para comentar c√≥digo    
üî• Control + K + U para descomentar

[Curso de Pensamiento L√≥gico: Algoritmos y Diagramas de Flujo](https://platzi.com/cursos/pensamiento-logico/)

üé≤

## 26. POO: tu siguiente paso con C#

```cs
```

üé≤üé≤üé≤üé≤üé≤üé≤üé≤

## Notas / Aportes
<details>
	<summary>Haz clic para ver a los contribuidores üëÄ</summary>
	<br/>
	
**üî• Team:**    
- Renato Reyes Fuentes
- Javier Guardia
- Gustavo Emilio Aguilera L√≥pez

</details>

üé≤

## Examen:     
<details>
  <summary>Haz click aqu√≠ para ver los resultados üëÄ</summary>

  <br/>

1. Es una sentencia de control de flujo que permite recorrer arreglos de manera simple y que no es necesario que definamos cu√°ndo terminar√°.
	- üìåforeach

2. Para crear nuevas instancias una clase se utiliza la palabra clave
	- üìånew

3. Un m√©todo en C# puede devolver: nada, un objeto, m√∫ltiples objetos. Esta afirmaci√≥n es...
	- üìåVerdadera

4. La compa√±√≠a Reversed Cross te ha pedido contabilizar el n√∫mero de personas que ingresan a la oficina los d√≠as domingo en la noche. Para tal fin debes modificar un segmento de c√≥digo que se activa cada vez que un sensor de movimiento env√≠a una se√±al. Este sensor env√≠a una se√±al por cada persona que ingresa. La forma m√°s conveniente de llevar este conteo puede ser cualquiera de las siguientes, ¬øcu√°l consideras que es la m√°s id√≥nea?
	- üìåpersona++;

5. El reconocido youtuber Nicol√°s Jaula, requiere algo de ayuda para su p√°gina web. √âl tiene un peque√±o c√≥digo C# que la plataforma le permite usar como plugin. Todos los c√°lculos los hace convirtiendo tipos string a tipo entero utilizando el tipo de dato Int, sin embargo tiene un l√≠o, ya que su audiencia le ha pedido que los deje ingresar datos en decimales ya que los n√∫meros decimales est√°n de moda. ¬øQu√© tipo de dato le sugerir√≠as usar a Nicol√°s para las variables?
	- üìåüìå Una variable float

6. Para crear comentarios en C#¬†**NO**¬†es v√°lido utilizar
	- üìå `

7. ¬øQu√© son los Workloads de Visual Studio?
	- üìå Son los paquetes de herramientas que podemos instalar en nuestro IDE para trabajar d√≠a a d√≠a con ellas.

8. ¬øCu√°l es la instrucci√≥n en C# que nos permite escribir una l√≠nea en nuestro programa?
	- üìå Console.WriteLine();

9. ¬øQu√© tipo de proyecto deber√≠a crear si quiero crear una aplicaci√≥n con interfaz gr√°fica?
	- üìå WPF App (Windows Presentation Foundation)

10. ¬øCu√°l de las siguientes afirmaciones describe mejor a los Namespaces?
	- üìå Un Namespace debe ser √∫nico en todo mi programa y debe representar algo significativo. Dentro de √©l pueden vivir varias clases y dentro de cada clase pueden vivir varios m√©todos.

11.¬øCu√°les son los dos valores que un tipo de dato booleano puede guardar en C#?
	- üìå true y false

12. ¬øCu√°l es la diferencia entre un tipo de dato "int" y uno "uint"?
	- üìå El tipo de dato int puede almacenar cualquier n√∫mero, sea positivo o negativo, siempre y cuando sean n√∫meros enteros, mientras que el uint √∫nicamente puede almacenar n√∫meros enteros positivos.

13. ¬øC√≥mo declarar√≠as una variable que guarde la cantidad de dinero que tienes ahorrado?
	- üìå float dineroAhorrado = 536.5f;

14. ¬øCu√°l es la funcionalidad de la palabra reservada "var" en C#?
	- üìå Permite declarar una variable y el lenguaje por su cuenta intuye qu√© tipo de dato es, sin embargo, no es una buena pr√°ctica usarlo.

15. ¬øCu√°l es la funci√≥n de C# que nos ayuda a transformar los n√∫meros que leemos del usuario a un tipo de dato int?
	- üìå Convert.ToInt32(numeroLeido);

16. ¬øCu√°les son los operadores l√≥gicos que encontramos en C# y c√≥mo se escriben?
	- üìå `&&, ||, !`

17. ¬øCu√°l ser√≠a el resultado de la operaci√≥n l√≥gica true && false?
	- üìå FALSE

18. ¬øPara qu√© nos sirven los operadores relacionales?
	- üìå Para establecer una relaci√≥n entre dos o m√°s valores (si son mayores, menores, iguales, etc.).

19. ¬øCu√°l operador podemos usar para unir dos o m√°s cadenas de texto en C#?
	- üìå `+`

20. ¬øCu√°l de las siguientes es la forma correcta de declarar una variable de tipo float en C#?
	- üìå float miVariable = 10.5f;

21. ¬øCu√°les son algunos de los operadores aritm√©ticos que soporta C#?
	- üìå `+, -, *, /`

22. ¬øCu√°l de las siguientes instrucciones de C# me permiten leer datos de mi usuario?
	- üìå Console.ReadLine();

23. ¬øCu√°l es una de las principales ventajas de un arreglo en C#?
	- üìå Nos permite guardar m√∫ltiples valores en una sola variable, lo cual nos ayuda a tener nuestro c√≥digo m√°s ordenado.

24. ¬øCu√°l es la sentencia que nos permite tomar decisiones dentro de nuestro programa?
	- üìå if

25. ¬øCu√°l es la sentencia que nos permite listar varias posibles opciones y el programa elegir√° la opci√≥n seg√∫n el valor de alguna variable?
	- üìå switch

26. ¬øCu√°l es la sentencia que nos permite repetir cierto bloque de c√≥digo mientras que una condici√≥n sea cierta?
	- üìå while

27. ¬øCu√°l es la sentencia que nos permite repetir cierto bloque de c√≥digo hasta un n√∫mero determinado de veces que nosotros le indiquemos?
	- üìå for

28. ¬øQu√© nos permiten las listas dentro de C#?
	- üìå Como su nombre lo indica, nos permite guardar una lista de elementos a los cuales podemos acceder y manipularlos siempre que queramos.  

29. ¬øCu√°l es una de las principales ramas en donde se usa C#?
	- üìå En el desarrollo de videojuegos

</details>

üé≤

## Emojis:  
<details>
  <summary>Haz click aqu√≠ para ver los emojis üëÄ</summary>

  <br/>

**üî• Emojis:**        
- üî•¬†‚ùÑ¬†‚ú®¬†üìå¬†üé≤ üîç¬†üéâ     
- ü§¥ü¶Å¬†üßîüêØ¬†¬†üëÄ üëâ üëà ‚òù üëá   
- üòä üëàüëÄ üòå üòç üßõ‚Äç‚ôÇÔ∏è üìÇ üìÅ   üóÇ 
- üü• ‚¨ú ‚¨õ ‚óº ‚óª üî∑ üî∂ üîª üî∫ üî¥ üü£ üîµ      
- ‚úî ‚ûï ‚Üï ‚Üî ‚û° ‚¨á ‚¨Ö ‚úÖ ‚ñ∂ ‚ùå ‚ùó            
- üß∞ ‚õì üí° üåê üñ•    üõ°    ‚ñ∂    
- üîÖ üîÜ üåö üåó       

</details>
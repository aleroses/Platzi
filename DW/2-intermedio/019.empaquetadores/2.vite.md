# Curso de Vite.js

## 1. ¿Qué es Vite?

Vite.js es una herramienta de desarrollo front-end creada por Evan You, el mismo desarrollador detrás de Vue.js. Su nombre, "Vite", proviene de la palabra francesa para "rápido", y está diseñada para proporcionar una experiencia de desarrollo extremadamente rápida. Aquí hay una explicación más detallada de sus características y ventajas:

### Características Principales de Vite.js

1. **Desarrollo Rápido**:
   - **Servidor de Desarrollo Instantáneo**: Vite lanza un servidor de desarrollo que proporciona una recarga en caliente rápida y eficiente. Esto se logra mediante la utilización de ES Modules nativos del navegador en lugar de empaquetar todos los archivos en uno solo.
   - **Compilación de Código en Demanda**: En lugar de empaquetar todo el proyecto al inicio, Vite sólo compila los módulos que realmente son necesarios y solicitados por el navegador, lo que mejora significativamente los tiempos de inicio.

2. **Compilación Optimizada**:
   - **Rollup**: Para la producción, Vite utiliza Rollup como motor de empaquetado, aprovechando su avanzada optimización y generación de código eficiente.
   - **Code Splitting Automático**: Vite divide automáticamente el código en fragmentos más pequeños, mejorando así el rendimiento de la aplicación en producción.

3. **Soporte a Múltiples Marcos**:
   - Aunque fue diseñado con Vue en mente, Vite es un agnóstico del framework y funciona bien con React, Preact, Svelte, y otros marcos populares.

4. **Configuración Simplificada**:
   - La configuración de Vite es sencilla y minimalista en comparación con otras herramientas de construcción como Webpack, lo que facilita su adopción y uso.

5. **Plugins y Extensibilidad**:
   - Vite tiene un sistema de plugins flexible basado en Rollup, lo que permite a los desarrolladores extender su funcionalidad de manera eficiente.

6. **Compatibilidad con TypeScript**:
   - Vite ofrece un soporte robusto para TypeScript, haciendo fácil su integración y uso dentro del proyecto.

### Ventajas de Usar Vite.js

1. **Rápida Iteración en Desarrollo**:
   - Gracias a su rápido servidor de desarrollo y la recarga en caliente eficiente, los desarrolladores pueden ver los cambios instantáneamente, mejorando la productividad y la experiencia de desarrollo.

2. **Configuración y Mantenimiento Simplificados**:
   - La configuración minimalista reduce el tiempo de configuración inicial y facilita el mantenimiento del proyecto a largo plazo.

3. **Óptimas Compilaciones para Producción**:
   - Las compilaciones de producción de Vite son rápidas y generan bundles optimizados, resultando en aplicaciones web más rápidas y eficientes.

### Ejemplo Básico de Uso

Para comenzar un proyecto con Vite, se puede usar el siguiente comando (asumiendo que Node.js y npm están instalados):

```sh
npm create vite@latest my-vite-project
cd my-vite-project
npm install
npm run dev
```

Esto iniciará un nuevo proyecto con Vite y lanzará un servidor de desarrollo.

### Conclusión

Vite.js es una herramienta poderosa y eficiente para el desarrollo de aplicaciones web modernas. Su enfoque en la rapidez y la simplicidad lo hace una excelente opción para desarrolladores que buscan mejorar su flujo de trabajo y reducir los tiempos de espera durante el desarrollo.

## 2. Historia del Ecosistema de JavaScript

Hablaremos de la **historia detrás de Vite**, los problemas que soluciona y todas las tecnologías, ideas y conceptos que hubo antes de su llegada.

### El ecosistema antes de Vite.js

Cuando la web comenzó, las páginas eran únicamente texto, con algunas imágenes y enlaces (HTML). Después surgieron los navegadores con la característica de procesar CSS, con el tiempo fue necesario agregar nuevas funcionalidades a la web, se necesitaba una web dinámica y como respuesta llego JS.

#### Módulos y librerías

A partir de este punto el código comenzó a crecer y se llegó a la siguiente pregunta: ¿Cómo hacemos para organizarlo mejor?, a lo que llegaron los **módulos y librerías**. Inicialmente, solo existía una forma, la cual era una etiqueta de HTML, como la siguiente:

```js
<script src="modulo.js"></script>
```

Esta etiqueta referenciaba el archivo o este mismo se encontraba dentro de ella. Básicamente, esto era un módulo, se cargaba el archivo y estaba listo para usarse, aunque surgieron los siguientes problemas:

- Siguió creciendo y ya no se tenía un solo módulo, sino muchísimos de estos.
- No se tenía ningún estándar
- Difícil de leer
- Se podían generar errores dependiendo el orden de importación
- Había posibilidades de una colisión entre variables

#### IIFE

Debido a los problemas anteriores, surgieron las **IIFE (Expresión de función ejecutada inmediatamente)**, las cuales se veían de la siguiente forma:

```js
(function(){ /*statements*/ })();
```

Estas consistían en una función normal en JS envuelta en unos paréntesis, para que en el momento en que se declara también se ejecutara. A la hora de usarla se veía de la siguiente forma y esto hacía que las variables se quedaran dentro del módulo, evitando la colisión de variables.

```js
var module = (function(){ var version = "1.0.0"; })(): 
// version es inaccesible
```

##### Minificacion

El proceso de **minificacion** surgió debido a la cantidad de código que se necesita para hacer web, este consiste en un tipo de compresión donde se **eliminan características del código que el navegador no necesitaba y solo estaban ahí para una mejor legibilidad**, por ejemplo, los espacios.

La minificacion ayudaba a la performance de la web en archivos grandes, este es él antes y después de un código minificado:

```js
// Sin minificar 
var data = { name: "Diana". age: 27 };
```

```js
// Minificado 
var data={name:"Diana",age:27};
```

#### Bundling

A veces tienes muchos módulos dentro de un mismo sitio web y muchos de estos los consumes al mismo tiempo. Aquí es donde entra el bundling, un proceso donde se toman todos estos módulos y lo conviertes en un solo archivo minificado y listo para utilizar.

![bundle](https://i.postimg.cc/jj2y25vG/2-buldle.png)

Cuando el usuario entra a la página web, el bundling en vez de tener que descargar todos estos archivos, solo debe descargar uno, mejorando el rendimiento.

### Primera generación

**Node.js** trae toda una revolución, permitiendo a las personas usar JS del lado del backend para modificar la forma en la que se comportan las páginas web. Con el diseño de esta, llegan las herramientas de primera generación, como por ejemplo los **templates** o las tecnologías de desarrollo.

- Templates: Un template o plantilla es cuando tomamos diferentes bloques de HTML, hacer que se junten y crear una página completa (Jade, Pug). Posteriormente, se implementó con CSS (Sass, stylus).

#### Herramientas para la automatización

Comienzan a surgir la necesidad de herramientas para automatizar estos procesos y se encarguen del orden de ejecutarlos, como por ejemplo Grunt y Gulp.

#### Yeoman Generator

Surgen herramientas como **_Yeoman Generator_**, que te permite generar código por medio de una herramienta de comandos, por ejemplo generar un componente con todo el código base a través de un solo comando.

#### Frameworks

Aparecen los primeros **frameworks** (Angular.js, Ember.js, Backbone.js) que traen consigo el concepto de trabajar con el lenguaje y estructura que te proveen. Surge la necesidad de tener múltiples carpetas y archivos, estructurados de una manera muy específica, los cuales tienen que pasar por la **transpilacion**, es decir, encontrarse en una etapa de desarrollo y luego generar una versión para producción.

#### ES6 & Babel.js

Aparece **ECMAScript 6** y con ello **Babel.js**, una herramienta que te permite utilizar ES6 (Estándar de JS) en desarrollo y luego convertirlo en una versión más antigua, para de esta manera ordenadores más antiguos poder ejecutar el código. De esta manera teniendo las últimas características de JS y siendo retro compatibles.

### Segunda generación de herramientas

Llega una nueva generación de herramientas que trae consigo:

- **Frameworks** nuevos como React.js, Vue.js y Angular io.
- **ESLINT** y **Prettier**, herramientas enfocadas en el desarrollo. Las cuales formatean el código con un código estándar, teniendo ahora un código más organizado.
- **Bundlers** como **Webpack**, **esbuild** o **parcel**

#### Webpack

Una de las herramientas que **más se emplea hoy en día**, la cual te permite hacer todos estos procesos que hemos estado viendo a lo largo del curso. El cual funciona mediante una configuración donde se pasan los archivos de desarrollo a código de producción.

Pero **Webpack** trae un gran problema, es **muy lento** y necesita **demasiada configuración**, surgiendo alternativas a este como **esbuild** (mucho más rápido), **parcel** (menos configuración necesaria) o **rollup** (código más optimizado).

#### TypeScript (TS)

Aparece **TS** un lenguaje de programación tipado que se **transpila hacia JS** bastante útil, pero esto conlleva reescribir todo el ecosistema para que sea compatible con JS, convirtiéndose en otra razón para hacer un cambio en la web.

### Tercera generación de herramientas

Finalmente, llegamos a **Vite**, una respuesta histórica a toda esta serie de procesos y complejidades, el cual trae una **mejor experiencia para los desarrolladores, con una mayor velocidad y sin necesidad de una configuración complicada.**

## 3. Características de Vite

Ahora que conocemos la historia detrás de Vite vamos a ver sus **principales características**, donde destaca la reinvención de muchos procesos, como la **resolución de dependencias, la implementación con TS, el HMR, entre muchas otras funcionalidades**.

### Optimización de código

Vite optimiza muchos de los procesos por los que tiene que pasar el código, para de tal modo enfocarse en un mejor rendimiento y experiencia de desarrollo.

#### Pre-bundling

Es la etapa donde se **estandarizan los módulos**, pues adapta módulos en _CommonJS_ o _UMD_ al formato estándar de _ECMAScript_.

#### Dependency resolving

Vite **optimiza el proceso en que se obtienen librerías y módulos estandarizados**. Funciona de la siguiente manera:

1. Utiliza un servidor estático para exponer los archivos vía URL.
2. Reemplaza los **imports vía NodeJS por imports URL**.
3. Sirve los archivos de forma inteligente y con cache, para optimizar tiempo y procesamiento.

#### Hot module replacement (HMR)

El HMR es cuando se hace un cambio en el código y este se ve reflejado en el navegador casi de forma inmediata, sin perder el estado de la aplicación y sin tener que recargar el navegador. Esto nos otorga una mejor experiencia de desarrollo al ser más rápido.

#### Importación de archivos

Nos otorgará una **importación de archivos simplificada**. * Resuelve la importación sin necesidad de loaders. * Es simple de usar con archivos multimedia, estilos, código o con los preprocesadores más comunes, incluyendo TypeScript.

#### Integración simple con TypeScript

TS es **automáticamente** sin necesidad de una configuración adicional **compatible con Vite**. Aun así, podrás agregarle una configuración adicional que funcionara con cualquier librería o framework.

### Optimizacion para produccion

Te proporcionará una serie de optimizaciones a la hora de transpilar para producción o hacer lo que llamamos el _build_.

- **Permite tomar el control de la configuración.** Podrás utilizar la configuración por defecto tanto en desarrollo como en producción, o bien, podrás tener una configuración más específica y controlada por ti.
- **La velocidad en desarrollo aumenta gracias a esbuild.**
- **Optimiza el bundle de producción gracias a Rollup**. La importación de dependencias se hace de modo inteligente, es decir, resuelve los módulos a emplear en el proyecto y predice hasta cierto punto los módulos que van a seguir, para importarlos desde un inicio.

### Soporte a Web Workers y Web Assembly

Los Web Workers son una característica de JS que nos permite **crear procesos alternativos al proceso principal**. Implementarlos puede llegar a tener una configuración complicada, pero con Vite no, teniendo la posibilidad de importarlos de una manera específica y estar listos para ser usados. Aunque tambien existe la posibilidad de importar un archivo Web Assembly e invocarlo donde queramos que se ejecute.

## 4. ¿Cómo instalar Vite?

```bash
npm create vite@latest
	Ok to proceed? (y) y
	✔ Project name: … spa-test
	❯ Vanilla
	❯ JavaScript

cd spa-test
npm install
code . -r
npm run dev
```

- [Vite](https://vitejs.dev/)
- [Stackblitz](https://stackblitz.com/edit/vitejs-vite-syiwmz?file=index.html&terminal=dev)

## 5. Boilerplate de Vite

Estructura por defecto:

```bash
.
├── counter.js
├── index.html
├── javascript.svg
├── main.js
├── node_modules
├── package.json
├── package-lock.json
├── public
│   └── vite.svg
└── style.css
```

### Que debemos recodar

1. Todas las configuraciones las podemos realizar en el archivo **[vite.config.js](https://vitejs.dev/config/)**
2. El punto de acceso por defecto es `index.html`, pero podemos cambiar para que sea un `.html, .js, .ts`
3. En el archivo punto `package.json` tenemos los scripts iniciales del proyecto
	- `$npm run dev` Levanta el servidor en desarrollo
	- `$npm run build` Genera la carpeta /dist donde están los archivos para producción.
	- `$npm run preview` Levanta un servidor que nos permite ver el proyecto generado en /dist
4. Cuando vemos el proyecto renderizado en el navegador podemos observar que agrega un parámetro que indica en **timestamp** que representa el momento cuando fue generado.

	- `<script type=”module” src=”/main.js?t=2345676344”></script>`
    Esto tiene relación a que los archivos están en el cache el navegador y para renderizar los cambios necesitamos que sean refrescados.
    
	- **Para forzar el limpiado de la cache** Importante resaltar que puede llegar a ser necesario _**FORZAR LIMPIAR LA CACHE PARA PODER VER LOS CAMBIOS**_
    
    Debemos seguir los pasos:
    
	    1. Click en los tres puntos superiores del navegador
	    2. “Más herramientas”/”Herramientas del desarrollador”/”Application”/Storage”
	    3. Marcar el check de “Cache”/”Cache storage”
	    4. Click en “Clear site data”
    
    O también
    
	    1. Click derecho
	    2. ”Inspeccionar”/”Application”/Storage”
	    3. Marcar el check de “Cache”/”Cache storage”
	    4. Click en “Clear site data”

	- Interesante ver el archivo `style.css` no es un archivo css normal. Cómo se hablo anteriormente Vite convierte todos los archivos en un archivo ECMAScript Module para usarlo de manera universal.

![](https://i.postimg.cc/Wbm6ttc4/5-cache.png)

[[spa-js-vanilla#3. Configurar el entorno de trabajo]]
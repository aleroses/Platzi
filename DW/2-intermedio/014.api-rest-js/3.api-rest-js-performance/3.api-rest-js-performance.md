# Curso de API REST con Javascript: Performance y Usabilidad

> 09/06/2024


## 1. Tu responsabilidad como frontend developer

## 2. Cach√© vs. memoria

### Cache (kÀà√¶ É)

Cache es la forma en la que le decimos al navegador que nos traiga la √∫ltima informaci√≥n guardada, es decir que si necesitamos algo de informaci√≥n simplemente env√≠e lo que tiene en cache.

**Propiedades**

- default -
- no-store -
- reload -
- no-cache -
- force-cache -
- only-if-cached -

Estos son todos los ‚Äúcondicionales‚Äù que el cach√© permite validar el ‚Äúestado‚Äù de la informaci√≥n.

### Memorization

Memoization (Si se escribe as√≠!!) Guardar los c√°lculos ‚ÄùPeticiones‚Äù que ya hicimos para no repetirlos.

### **Posibles Problemas**

- Nosotros no sabemos si ha cambiado la informaci√≥n del back-end.
- Nosotros no sabemos si la cache o memorization est√° actualizada o des-actualizada.

En resumen es:

Crear un objeto. Preguntar si el objeto tiene la informaci√≥n que necesitamos Si s√≠, usar la informaci√≥n Si no, hacer el fetch y guardar la informaci√≥n en el objeto 

Consideraciones importantes.

JavaScript √∫nicamente guarda la informaci√≥n en tiempo de ejecuci√≥n si esta informaci√≥n se hace reload se va a perder.

## 3. Debuggeando cach√© y networking

Descarga el proyecto anterior

[[debugging-devtools#16. ¬øCu√°ndo utilizar Network en DevTools?]]

## Quiz: Qu√© se debe optimizar en el frontend (y qu√© no)

1. ¬øQu√© t√©cnicas se pueden utilizar para maximizar la eficiencia de la carga de datos?

	- Cach√©

2. ¬øPor qu√© es importante considerar la carga y optimizaci√≥n de datos en el frontend?

	- Para brindar una buena experiencia a los usuarios

3. How does memorization improve the performance of an application?

	- By avoiding the repetition of complex computations.

3. ¬øQu√© se menciona acerca de la funci√≥n de recarga de la p√°gina?

	- Se explica c√≥mo se recargan diferentes elementos al realizar una recarga fuerte.

4. What is memorization in JavaScript?

	- A technique to store previously computed results or API responses.

## 4. Loading spinners vs. loading skeletons

Buenas caracter√≠sticas de las pantallas de carga:

- Facilitan la comprensi√≥n del estado de carga
- Son amigables con el tiempo de carga
- Hacen que la experiencia de carga sea divertida

Tenemos dos estrategias principales para manejar las pantallas de carga:

### Loading spinners

- Un anillo animado que indica que algo se est√° cargando
- No proporciona informaci√≥n clara sobre lo que se est√° cargando
- No nos permite saber si hemos perdido la conexi√≥n WiFi o si la web se ha bloqueado

### Loading skeletons

- Tienen buenas pr√°cticas que los usuarios disfrutan
- Proporcionan una representaci√≥n visual de lo que se est√° cargando, lo que hace que la espera sea m√°s informativa
- Pueden reducir la percepci√≥n del tiempo de carga al mostrar la estructura de la p√°gina mientras se cargan los contenidos detallados

![](https://i.postimg.cc/hvRwMjDH/4-spinner-skeleton-loader.jpg)

## 5. Reto: pantalla de carga

Ejemplo de Animaci√≥n simple:

`index.html`

```html
<section class="container">
  <div class="item loading"></div>
  <div class="item loading"></div>
  <div class="item loading"></div>
  <div class="item loading"></div>
</section>
```

`styles.css`

```css
.container {
  display: flex;
  gap: 30px;
}
.item {
  width: 80px;
  height: 80px;
  background-color: darkslateblue;
}

.loading {
  animation: insane infinite 1.5s;
}

@keyframes insane {
  0%,
  100% {
    opacity: 100%;
  }

  50% {
    opacity: 50%;
  }
}
```

![](https://i.postimg.cc/tCmR2bk3/5-animation.png)

## 6. Intersection Observer

[[manipulacion-dom#Curso de Manipulaci√≥n del DOM#22. Intersection Observer]]

V√≠deos que pueden ayudarte a practicar; adem√°s, complementar a√∫n m√°s el conocimiento del curso.

- [Intersection Observer](https://www.youtube.com/watch?v=cVsqA4NhDoI&t=33s)
- [Scroll Infinito](https://www.youtube.com/watch?v=m5yS-RsKGTw&t=3s)

## 7. Lazy Loading

[[manipulacion-dom#23. Aplicando Lazy loading#Atributos data*]]

## 8. Im√°genes por defecto

Tener cuidado con la medida o tama√±o de las im√°genes al cargar, esto podr√≠a estar afectando el Lazy Loading. Por lo que se recomienda a√±adir un `min-height` desde el inicio y despu√©s sobreescribirlo con la medida real.

## Quiz: Optimizaci√≥n de im√°genes

1. What approach does the author prefer for solving the problem of lazy loading?

	- Using an intersection observer in JavaScript

2. ¬øPor qu√© la ruedita de carga no cumple con las pr√°cticas adecuadas?

	- No indica qu√© se est√° cargando ni cu√°nto tiempo falta.

3. What is the initial visibility of the images when the page is reloaded?

	- Only one specific image is visible

4. ¬øQu√© es Lazy Lading?

	- Indicarle a nuestras im√°genes que no carguen todas desde el principio, sino √∫nicamente cuando los usuarios lleguen a esa parte de la app.

5. ¬øQu√© es el churn rate?

	- La cantidad de usuarios que entran a nuestra app, pero luego la abandonan.

## 9. Scroll infinito vs. paginaci√≥n

## 10. Bot√≥n de cargar m√°s

## 11. Infinite Scrolling: evento de scroll

### Qu√© es `document.documentElement`

`document.documentElement` es una propiedad de solo lectura del objeto `document` en el DOM (Document Object Model). Representa el elemento ra√≠z del documento, que es el elemento `<html>` en un documento HTML.

A trav√©s de esta propiedad, se puede acceder y manipular el contenido y los atributos del elemento `<html>` directamente. 

### C√≥mo funciona

El elemento `<html>` es el contenedor principal de todo el contenido de una p√°gina web, y `document.documentElement` proporciona una referencia directa a este elemento. Al acceder a `document.documentElement`, puedes manipular el elemento `<html>` de la misma manera que lo har√≠as con cualquier otro nodo del DOM.

### Propiedades y Atributos Comunes

El elemento `document.documentElement`, que corresponde al elemento `<html>` en un documento HTML, tiene varios atributos y propiedades que puedes utilizar. A continuaci√≥n, se detallan algunos de los m√°s importantes y c√≥mo se pueden usar:

#### 1. Acceder al elemento `<html>`

Puedes acceder al elemento `<html>` y leer sus atributos o propiedades:

```javascript
// Acceder al elemento <html>
var htmlElement = document.documentElement;

console.log(htmlElement); // Muestra el elemento <html> completo
```

#### 2. Cambiar el idioma del documento

Puedes cambiar el atributo `lang` del elemento `<html>`:

```javascript
// Cambiar el idioma del documento a espa√±ol
document.documentElement.lang = "es";

// Cambiar el idioma del documento al ingl√©s
document.documentElement.lang = "en";
```

#### 3. Aplicar estilos al elemento `<html>`

Puedes aplicar estilos directamente al elemento `<html>` usando `document.documentElement`:

```javascript
// Cambiar el color de fondo del elemento <html>
document.documentElement.style.backgroundColor = "lightblue";
```

#### 4. Obtener el ancho y alto del viewport

`document.documentElement` es √∫til para obtener el tama√±o del viewport (la parte visible de la p√°gina):

```javascript
// Obtener el ancho del viewport
var viewportWidth = document.documentElement.clientWidth;

// Obtener el alto del viewport
var viewportHeight = document.documentElement.clientHeight;

console.log("Ancho del viewport:", viewportWidth);
console.log("Alto del viewport:", viewportHeight);
```

#### 5. Desplazamiento del documento

Estas propiedades devuelven o establecen la posici√≥n de desplazamiento vertical y horizontal del documento.

```javascript
// Obtener la posici√≥n de desplazamiento vertical
var scrollTop = document.documentElement.scrollTop;

console.log("Posici√≥n de desplazamiento vertical:", scrollTop);

// Establecer la posici√≥n de desplazamiento vertical
document.documentElement.scrollTop = 100;

// Obtener la posici√≥n de desplazamiento horizontal
var scrollLeft = document.documentElement.scrollLeft;

console.log("Posici√≥n de desplazamiento horizontal:", scrollLeft);

// Establecer la posici√≥n de desplazamiento horizontal
document.documentElement.scrollLeft = 100;
```

#### 6. `document.documentElement.dir`

Este atributo establece o devuelve la direcci√≥n del texto del documento (`ltr` para izquierda a derecha o `rtl` para derecha a izquierda).

```javascript
// Obtener la direcci√≥n del texto del documento
var dir = document.documentElement.dir;

console.log("Direcci√≥n del texto del documento:", dir);

// Establecer la direcci√≥n del texto del documento a derecha a izquierda
document.documentElement.dir = "rtl";
```

#### 7. `document.documentElement.title`

Aunque generalmente se accede y se manipula a trav√©s del elemento `<title>`, tambi√©n puedes acceder al t√≠tulo del documento a trav√©s de `document.documentElement`.

```javascript
// Obtener el t√≠tulo del documento
var title = document.title;

console.log("T√≠tulo del documento:", title);

// Establecer un nuevo t√≠tulo para el documento
document.title = "Nuevo T√≠tulo";
```

### Propiedades del Documento

#### `document.documentElement.offsetWidth` y `document.documentElement.offsetHeight`

Estas propiedades devuelven el ancho y el alto del elemento `<html>` incluyendo los bordes.

```javascript
// Obtener el ancho del elemento <html> incluyendo los bordes
var offsetWidth = document.documentElement.offsetWidth;

// Obtener el alto del elemento <html> incluyendo los bordes
var offsetHeight = document.documentElement.offsetHeight;

console.log("Ancho del elemento <html>:", offsetWidth);
console.log("Alto del elemento <html>:", offsetHeight);
```

**Dato**:

- Usa `clientHeight` cuando necesitas saber la altura del √°rea visible al usuario.
- Usa `offsetHeight` cuando necesitas la altura total del elemento, incluyendo los bordes y el scrollbar. üìå Su comportamiento puede variar.

Adem√°s:

```js
// Incluye solo el padding, no los bordes.
document.documentElement.scrollHeight
```

### M√©todos de Manipulaci√≥n

#### `document.documentElement.getBoundingClientRect()`

Este m√©todo devuelve un objeto `DOMRect` que proporciona informaci√≥n sobre el tama√±o del elemento y su posici√≥n relativa al viewport.

```javascript
// Obtener las dimensiones y la posici√≥n del elemento <html>
var rect = document.documentElement.getBoundingClientRect();

console.log("Dimensiones y posici√≥n del elemento <html>:", rect);
```

Ejemplo:

```js
DOMRect {
    "x": 0,
    "y": -304,
    "width": 320,
    "height": 964,
    "top": -304,
    "right": 320,
    "bottom": 660,
    "left": 0
}
```

üìå Lo curioso es que si sumamos `document.documentElement.scrollTop + document.documentElement.clientHeight` obtendremos el total de scroll que podemos hacer.

![](https://i.postimg.cc/02dcnZw3/11-scroll.png)

### üî• `window.removeEventListener("scroll", infiniteScroll, ¬øparametro?üëàüëÄ);`

El tercer par√°metro en los m√©todos `addEventListener` y `removeEventListener` se utiliza para especificar opciones adicionales para el evento. Este par√°metro puede ser un valor booleano (true o false) o un objeto de opciones. 

#### Uso del tercer par√°metro en `removeEventListener`

El tercer par√°metro en `removeEventListener` **debe coincidir** con el tercer par√°metro utilizado en `addEventListener` para que la eliminaci√≥n del evento sea efectiva.

#### Casos de uso y aplicaci√≥n en `addEventListener`

En `addEventListener`, el tercer par√°metro puede ser un booleano o un objeto. Aqu√≠ hay un resumen:

1. **Booleano (`true` o `false`)**:
   - **`true`**: La fase de captura. El evento se captura en la fase de captura, antes de llegar al objetivo del evento.
   - **`false`**: La fase de burbuja. El evento se maneja en la fase de burbuja, despu√©s de que se ha propagado desde el objetivo hacia afuera. Este es el comportamiento predeterminado.

2. **Objeto de opciones**: Este objeto puede tener varias propiedades, como:
   - **`capture`** (booleano): Equivalente a usar `true` o `false` directamente.
   - **`once`** (booleano): Si es `true`, el evento se ejecuta solo una vez y luego se elimina autom√°ticamente.
   - **`passive`** (booleano): Si es `true`, indica que el manejador de eventos nunca llamar√° a `preventDefault`, mejorando el rendimiento en algunos casos como el desplazamiento (scrolling) o en eventos como `touchstart` y `touchmove`.

#### Ejemplo de `removeEventListener` y `addEventListener`

```javascript
// Definimos una funci√≥n de manejo de eventos
function infiniteScroll() {
    console.log('Scrolled');
}

// A√±adimos el evento usando un objeto de opciones
window.addEventListener("scroll", infiniteScroll, {
  capture: false,
  passive: true,
  once: false
});

// M√°s tarde, removemos el evento usando los mismos par√°metros
window.removeEventListener("scroll", infiniteScroll, {
  capture: false,
  passive: true
});
```

#### Fase de captura y fase de burbuja

- **Fase de captura (true)**: En esta fase, el evento se propaga desde el elemento `window` (o el m√°s alto en el DOM) hacia el objetivo del evento. Si se establece el tercer par√°metro como `true` o se usa `{ capture: true }`, el evento ser√° capturado durante esta fase.

- **Fase de burbuja (false)**: Despu√©s de que el evento alcanza su objetivo, comienza a propagarse de regreso hacia el elemento `window` (o el m√°s alto en el DOM). üî• Este es el comportamiento predeterminado, y se puede especificar con `false` o `{ capture: false }`.

##### Ejemplo de `addEventListener` con booleano

```javascript
// Definimos una funci√≥n de manejo de eventos
function handleClick(event) {
    console.log('Clicked', event.target);
}

// A√±adimos el evento para la fase de burbuja
document.getElementById('myElement').addEventListener('click', handleClick, false);

// A√±adimos el evento para la fase de captura
document.getElementById('myElement').addEventListener('click', handleClick, true);

// Removemos el evento para la fase de burbuja
document.getElementById('myElement').removeEventListener('click', handleClick, false);

// Removemos el evento para la fase de captura
document.getElementById('myElement').removeEventListener('click', handleClick, true);
```

En resumen, el tercer par√°metro en `addEventListener` y `removeEventListener` proporciona un control m√°s granular sobre c√≥mo y cu√°ndo se deben manejar los eventos, y su uso correcto es esencial para la gesti√≥n eficiente de eventos en aplicaciones web.

#### `preventDefault` y su Relaci√≥n con los Eventos

`preventDefault` es un m√©todo que se usa en el manejo de eventos para evitar el comportamiento predeterminado del navegador asociado con el evento. Por ejemplo:

- Evitar que un enlace (`<a>`) navegue a otra p√°gina.
- Evitar que un formulario (`<form>`) se env√≠e.
- Evitar el comportamiento de desplazamiento (scroll) en ciertos eventos.

##### Ejemplo de `preventDefault`

```javascript
document.getElementById('myLink').addEventListener('click', function(event) {
    event.preventDefault(); // Evita que el enlace navegue
    console.log('Enlace clickeado, pero navegaci√≥n evitada.');
});
```

#### Par√°metro `passive`

El par√°metro `passive` en `addEventListener` es una optimizaci√≥n de rendimiento. Cuando `passive` se establece en `true`, le indica al navegador que el manejador de eventos no llamar√° a `preventDefault`. Esto permite que el navegador optimice el rendimiento en algunos casos, como el desplazamiento (scroll), ya que el navegador no necesita esperar a ver si `preventDefault` ser√° llamado.

##### Relaci√≥n entre `passive` y `preventDefault`

- **`passive: true`**: Indica que el evento es "pasivo". No se llamar√° a `preventDefault` en el manejador de eventos.
  - Ventaja: Mejor rendimiento, especialmente para eventos de desplazamiento (scroll), ya que el navegador puede proceder con el comportamiento predeterminado sin esperar a que el manejador del evento lo bloquee.
  - Restricci√≥n: Intentar llamar a `preventDefault` lanzar√° un error en la consola.

- **`passive: false`**: Indica que el evento es "activo". Se puede llamar a `preventDefault` para evitar el comportamiento predeterminado.
  - Ventaja: Permite prevenir el comportamiento predeterminado del navegador.
  - Desventaja: Puede resultar en un rendimiento menos √≥ptimo en algunos casos, como el desplazamiento (scroll), porque el navegador necesita esperar para ver si `preventDefault` ser√° llamado.

##### Ejemplo de `passive`

###### Con `passive: true`

```javascript
window.addEventListener('scroll', function(event) {
    console.log('Scrolled');
}, { passive: true });

// Este c√≥digo no funciona si se intenta llamar a preventDefault dentro del manejador:
// window.addEventListener('scroll', function(event) {
//     event.preventDefault(); // Esto lanzar√° un error
// }, { passive: true });
```

###### Con `passive: false`

```javascript
window.addEventListener('scroll', function(event) {
    event.preventDefault(); // Esto es permitido
    console.log('Scrolled and default behavior prevented');
}, { passive: false });
```

El valor por defecto del par√°metro `passive` es `false`. Esto significa que, a menos que se especifique expl√≠citamente lo contrario, los manejadores de eventos se tratar√°n como no pasivos, permitiendo el uso de `preventDefault` dentro del manejador de eventos.

Si no se especifica el par√°metro `passive`, se asume `false` por defecto:

```javascript
// Sin especificar passive, se asume passive: false
window.addEventListener('scroll', function(event) {
    event.preventDefault(); // Esto es permitido por defecto
    console.log('Scrolled and default behavior prevented');
});
```

En resumen:

- **`preventDefault`**: M√©todo para prevenir el comportamiento predeterminado del navegador asociado con el evento.
- **`passive`**: Un par√°metro en `addEventListener` que, cuando se establece en `true`, indica que no se llamar√° a `preventDefault` en el manejador de eventos, permitiendo optimizaciones de rendimiento.
- **Valor por defecto de `passive`**: `false`.
- **Comportamiento predeterminado**: Permite el uso de `preventDefault`.
- **Relaci√≥n**: Si `passive` es `true`, no se puede usar `preventDefault` en el manejador de eventos. Si `passive` es `false`, se puede usar `preventDefault`, pero puede impactar el rendimiento.
- **Especificar `passive: true`**: Indica que `preventDefault` no se usar√°, mejorando el rendimiento para ciertos eventos.

Usar `passive: true` es una buena pr√°ctica para eventos de desplazamiento (scroll) y otros eventos de alta frecuencia, donde no se necesita prevenir el comportamiento predeterminado.

#### üìå Dato

`Passive` lo que hace es evitar el llamado de `preventDefault()` en el caso de que este existiese en la funci√≥n llamada por el Listener. 

En los navegadores que usa la gente normal el valor **por defecto es false** por lo que no se aplica, pero en el caso de Safari e Internet Explorer el valor por defecto es true. 

Por lo que supongo que es recomendable ponerle un valor para que el c√≥digo se ejecute igual en todos los navegadores.

## 12. Infinite Scrolling: limitando la carga de datos

## 13. Infinite Scrolling: closures de navegaci√≥n

[[closures_scope-en-js#**7.** ¬øQu√© es un Closure?]]

En JavaScript, el patr√≥n `example()()` es una forma de "funci√≥n de orden superior" o una "funci√≥n que devuelve otra funci√≥n". Este patr√≥n se usa en varios contextos, como la creaci√≥n de funciones que configuran algo y luego devuelven otra funci√≥n que hace el trabajo real, currying, o closures.

Aqu√≠ hay algunos ejemplos de situaciones en las que se podr√≠a usar este patr√≥n:

### 1. Funci√≥n que devuelve otra funci√≥n

```javascript
function example() {
  return function() {
    console.log('Hello, world!');
  };
}

example()(); // Llama a example, que devuelve otra funci√≥n, y luego llama a esa funci√≥n
```

### 2. Currying

Currying es una t√©cnica en la que una funci√≥n que acepta m√∫ltiples argumentos se descompone en una serie de funciones que aceptan un solo argumento.

```javascript
function add(a) {
  return function(b) {
    return a + b;
  };
}

const add5 = add(5); // add5 ahora es una funci√≥n que suma 5 a su argumento
console.log(add5(10)); // 15

console.log(add(3)(4)); // 7
```

### 3. Closures

Las closures permiten que una funci√≥n interna acceda al alcance de una funci√≥n externa, incluso despu√©s de que la funci√≥n externa haya terminado de ejecutarse.

```javascript
function makeCounter() {
  let count = 0;
  return function() {
    count++;
    return count;
  };
}

const counter = makeCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```

En este ejemplo, `makeCounter` devuelve una funci√≥n que incrementa y devuelve el valor de `count` cada vez que se llama.

### 4. Configuraci√≥n de funciones

A veces se usa para configurar una funci√≥n antes de usarla.

```javascript
function configureGreeting(greeting) {
  return function(name) {
    console.log(greeting + ', ' + name + '!');
  };
}

const sayHello = configureGreeting('Hello');
sayHello('Alice'); // Hello, Alice!
sayHello('Bob'); // Hello, Bob!

configureGreeting('Hi')('Charlie'); // Hi, Charlie!
```

En este ejemplo, `configureGreeting` es una funci√≥n que toma un saludo y devuelve otra funci√≥n que toma un nombre y muestra un saludo personalizado.

Estos son algunos de los casos comunes en los que se utiliza el patr√≥n de `example()()`.

## Quiz: Paginaci√≥n

1. Which strategy does the author suggest for the Platzi Movies platform?
Elige la respuesta correcta

	- The text does not explicitly mention a specific strategy for Platzi Movies

2. What is the most common approach provided by APIs?
Elige la respuesta correcta

	- Pagination

3. What feature is enabled by implementing this validation process?
Elige la respuesta correcta

	- Infinite scroll

4. What is the error in the code regarding the 'Load More' button?
Elige la respuesta correcta

	- The button variable is not defined correctly

5. What does the text mention about the implementation of pagination in a web page?
Elige la respuesta correcta

	- It highlights the issue of the infiniteScroll variable not being defined correctly.

## 14. Local Storage vs. API real

### Local Storage vs. API real

**Local Storage** y **API real** son dos m√©todos com√∫nmente utilizados en aplicaciones web para almacenar y recuperar datos. Ambos tienen sus propias ventajas y desventajas y se usan en diferentes contextos dependiendo de los requisitos de la aplicaci√≥n. Aqu√≠ hay una comparaci√≥n de ambos:

### Local Storage

**Local Storage** es una caracter√≠stica del navegador web que permite almacenar datos en el cliente de manera persistente. Los datos almacenados en Local Storage no se eliminan cuando se cierra el navegador, lo que lo hace √∫til para guardar informaci√≥n que necesita persistir entre sesiones del usuario.

#### Ventajas de Local Storage

1. **Persistencia**: Los datos almacenados en Local Storage persisten incluso despu√©s de cerrar el navegador.
2. **F√°cil de usar**: La API de Local Storage es simple y directa, con m√©todos como `setItem`, `getItem`, `removeItem`, y `clear`.
3. **R√°pido acceso**: Los datos est√°n almacenados localmente, lo que permite un acceso r√°pido sin necesidad de realizar una llamada a un servidor.
4. **Independencia de red**: No requiere conexi√≥n a Internet para acceder a los datos almacenados.

#### Desventajas de Local Storage

1. **Capacidad limitada**: Generalmente, los navegadores limitan Local Storage a unos pocos megabytes.
2. **Seguridad**: Los datos almacenados en Local Storage no est√°n encriptados, lo que significa que pueden ser vulnerables a ataques si no se manejan adecuadamente.
3. **Sin sincronizaci√≥n**: Los datos no se sincronizan autom√°ticamente entre diferentes dispositivos o sesiones de navegador.
4. **Solo strings**: Local Storage solo almacena datos en formato de string, lo que significa que otros tipos de datos deben ser convertidos a string (por ejemplo, usando JSON).

### API Real

Una **API real** (Application Programming Interface) se refiere a un servicio remoto que permite a una aplicaci√≥n web interactuar con un servidor para almacenar y recuperar datos. Esto suele involucrar el uso de HTTP(S) para comunicarse con un servidor backend.

#### Ventajas de una API real

1. **Capacidad ilimitada**: En teor√≠a, no hay l√≠mite en la cantidad de datos que se pueden almacenar en el servidor.
2. **Seguridad**: Los datos pueden ser encriptados y protegidos por medidas de seguridad robustas en el servidor.
3. **Sincronizaci√≥n**: Los datos pueden ser accedidos y actualizados desde m√∫ltiples dispositivos y sesiones de navegador, manteni√©ndose sincronizados.
4. **Datos complejos**: Las APIs pueden manejar datos complejos y estructurados, no limitados a strings.

#### Desventajas de una API real

1. **Dependencia de red**: Requiere una conexi√≥n a Internet para acceder a los datos.
2. **Latencia**: Acceder a datos a trav√©s de una red puede ser m√°s lento que acceder a datos almacenados localmente.
3. **Complejidad**: Configurar y mantener una API real puede ser m√°s complejo que usar Local Storage, especialmente en t√©rminos de manejo de seguridad y escalabilidad.
4. **Costos**: Ejecutar un servidor y manejar una base de datos puede incurrir en costos adicionales.

### Cu√°ndo usar cada uno

**Local Storage** es ideal para:

- Almacenar configuraciones y preferencias del usuario.
- Datos que necesitan persistir entre sesiones del navegador pero no requieren sincronizaci√≥n entre dispositivos.
- Aplicaciones simples que no necesitan interactuar con un servidor backend.

**API real** es ideal para:

- Aplicaciones que requieren persistencia y sincronizaci√≥n de datos en m√∫ltiples dispositivos.
- Almacenamiento de grandes vol√∫menes de datos.
- Aplicaciones que necesitan manejar datos sensibles y requieren medidas de seguridad avanzadas.
- Funcionalidades complejas que necesitan comunicaci√≥n continua con un servidor backend.

En resumen, la elecci√≥n entre Local Storage y una API real depende de las necesidades espec√≠ficas de tu aplicaci√≥n, incluyendo el tipo de datos que manejas, los requisitos de persistencia, la necesidad de sincronizaci√≥n y las consideraciones de seguridad.

### **Datos interesantes**

- El local Storage guarda de 5 a 10mb de datos (dependiendo del navegador)
- No necesita bases de datos ni backend
- Excelente para probar ideas y hacer testing de funcionalidades
- Solamente guarda STRINGS
- Se guarda por cada navegador
- Es inseguro para guardar informaci√≥n

Informaci√≥n relevante¬†[en este link](https://www.tiny.cloud/blog/javascript-localstorage/)

## 15. Bot√≥n de like

Evitar la propagaci√≥n del evento:

```js
movieButton.addEventListener("click", (event) => {
  event.stopPropagation();
  console.log("Agregar pelicula");
  movieButton.classList.toggle("movie-btn--liked");
});
```

## 16. Guardando pel√≠culas en Local Storage

LocalStorage es una caracter√≠stica del navegador web que permite almacenar datos de manera persistente en el navegador del usuario. A diferencia de las cookies, los datos almacenados en LocalStorage no se env√≠an al servidor con cada solicitud HTTP, y se mantienen incluso si el navegador se cierra y se vuelve a abrir. LocalStorage es parte de la API de almacenamiento web de HTML5.

Aqu√≠ te explico c√≥mo usar LocalStorage con JavaScript:

### Guardar datos en LocalStorage

Para guardar datos, se utiliza el m√©todo `setItem`. Este m√©todo acepta dos argumentos: la clave (key) y el valor (value). Ambos deben ser cadenas de texto.

```javascript
localStorage.setItem('nombre', 'Juan');
localStorage.setItem('edad', '30');
```

### Recuperar datos de LocalStorage

Para recuperar datos, se utiliza el m√©todo `getItem`, que acepta una clave como argumento y devuelve el valor asociado a esa clave.

```javascript
let nombre = localStorage.getItem('nombre');
let edad = localStorage.getItem('edad');

console.log(nombre); // "Juan"
console.log(edad);   // "30"
```

### Eliminar datos de LocalStorage

Para eliminar un elemento espec√≠fico de LocalStorage, se usa el m√©todo `removeItem`, que acepta la clave del elemento a eliminar.

```javascript
localStorage.removeItem('nombre');
```

### Limpiar todos los datos de LocalStorage

Para eliminar todos los datos almacenados en LocalStorage, se usa el m√©todo `clear`.

```javascript
localStorage.clear();
```

### Verificar si una clave existe en LocalStorage

Aunque no hay un m√©todo directo para verificar si una clave existe, se puede hacer comprobando si `getItem` devuelve `null`.

```javascript
if (localStorage.getItem('nombre') !== null) {
  console.log('La clave existe');
} else {
  console.log('La clave no existe');
}
```

### Almacenar y recuperar objetos JSON

Dado que LocalStorage solo almacena cadenas de texto, para almacenar objetos JSON se deben convertir a cadenas usando `JSON.stringify`, y para recuperarlos se usa `JSON.parse`.

```javascript
// Almacenar un objeto
let usuario = { nombre: 'Juan', edad: 30 };
localStorage.setItem('usuario', JSON.stringify(usuario));

// Recuperar un objeto
let usuarioGuardado = JSON.parse(localStorage.getItem('usuario'));
console.log(usuarioGuardado.nombre); // "Juan"
console.log(usuarioGuardado.edad);   // 30
```

### Ejemplo completo

Aqu√≠ tienes un ejemplo completo que muestra c√≥mo usar LocalStorage para almacenar, recuperar y eliminar datos:

```html
<!DOCTYPE html>
<html>
  <head>
    <title>Ejemplo de LocalStorage</title>
    <script>
      function guardarDatos() {
        let nombre =
          document.getElementById("nombre").value;
        let edad = document.getElementById("edad").value;
        localStorage.setItem("nombre", nombre);
        localStorage.setItem("edad", edad);
        mostrarDatos();
      }

      function mostrarDatos() {
        let nombre = localStorage.getItem("nombre");
        let edad = localStorage.getItem("edad");
        document.getElementById("datos").innerHTML =
          "Nombre: " + nombre + "<br>Edad: " + edad;
      }

      function eliminarDatos() {
        localStorage.removeItem("nombre");
        localStorage.removeItem("edad");
        mostrarDatos();
      }

      window.onload = function () {
        mostrarDatos();
      };
    </script>
  </head>
  <body>
    <h1>Ejemplo de LocalStorage</h1>
    <label for="nombre">Nombre:</label>
    <input type="text" id="nombre" />
    <br />
    <label for="edad">Edad:</label>
    <input type="text" id="edad" />
    <br />
    <button onclick="guardarDatos()">Guardar Datos</button>
    <button onclick="eliminarDatos()">
      Eliminar Datos
    </button>
    <h2>Datos Almacenados:</h2>
    <div id="datos"></div>
  </body>
</html>
```

Este c√≥digo crea una p√°gina HTML sencilla que permite al usuario ingresar un nombre y una edad, almacenarlos en LocalStorage y mostrarlos en la p√°gina. Tambi√©n permite eliminar los datos almacenados.

### Objetos en el localStorage

Para trabajar con objetos primero debemos convertirlos en strings. Luego, al recuperarlos se debe volver a convertir en objeto.

```js
// En consola
localStorage
localStorage.clear()

const data = {
  name: "Ale Roses",
  age: 12,
  nickname: "ghost",
};

localStorage.setItem("data", JSON.stringify(data));

localStorage
// Storage¬†{data: '{"name":"Ale Roses","age":12,"nickname":"ghost"}', length: 1}

const info = JSON.parse(localStorage.getItem("data"));

info
// {name: 'Ale Roses', age: 12, nickname: 'ghost'}
```

## 17. Lista de pel√≠culas favoritas

## Quiz: Performance y Usabilidad

1. What does the author recommend for storing temporary data?
Elige la respuesta correcta

	- Session storage

2. What are the advantages of using an API for storing private data?
Elige la respuesta correcta

	- It provides more control and security

3. What is the purpose of using console.log in this code snippet?
Elige la respuesta correcta

	- To log the result of retrieving the likedMovies item from localStorage

4. Which method is used to retrieve the likedMovies item from localStorage?
Elige la respuesta correcta

	- getItem

5. After converting the 'liked movies' into an array, what is the next step in the process?
Elige la respuesta correcta

	- Calling the 'createMovies' function

## 18. Reto: selecci√≥n de idioma

Revisar la API the movies db [languages](https://developer.themoviedb.org/docs/languages):

![](https://i.postimg.cc/vBydmNzQ/18-language.png)

![](https://i.postimg.cc/0yJg0sXk/18-language-2.png)

### `Navigator.language` üëàüëÄ

`Navigator.language` es una propiedad en JavaScript que devuelve el c√≥digo de idioma del navegador. Este c√≥digo de idioma sigue generalmente el est√°ndar de IETF BCP 47, como "en-US" para ingl√©s (Estados Unidos) o "es-ES" para espa√±ol (Espa√±a).

Aqu√≠ te explico c√≥mo usar `Navigator.language`:

### 1. Obtener el idioma del navegador
Puedes obtener el idioma predeterminado del navegador simplemente accediendo a la propiedad `navigator.language`:

```javascript
const userLanguage = navigator.language || navigator.userLanguage;
console.log(userLanguage); // Ejemplo: "en-US"
```

### 2. Uso pr√°ctico
Usar el idioma del navegador puede ser √∫til para personalizar la experiencia del usuario, como mostrar contenido en el idioma preferido del usuario.

#### Ejemplo: Mostrar un mensaje de bienvenida en el idioma del usuario

```javascript
const userLanguage = navigator.language || navigator.userLanguage;

const messages = {
  "en-US": "Welcome!",
  "es-ES": "¬°Bienvenido!",
  "fr-FR": "Bienvenue!"
};

const defaultMessage = "Welcome!";
const message = messages[userLanguage] || defaultMessage;

console.log(message); // Muestra el mensaje en el idioma del usuario, si est√° definido, o el mensaje por defecto.
```

### 3. Consideraciones
- `navigator.language` solo devuelve el idioma preferido del navegador, no la configuraci√≥n regional completa del usuario.
- Algunos navegadores pueden devolver solo el c√≥digo de idioma sin la configuraci√≥n regional (por ejemplo, "en" en lugar de "en-US").
- Si necesitas m√°s detalles sobre los idiomas aceptados por el navegador, puedes usar `navigator.languages`, que devuelve una lista ordenada de los idiomas preferidos del usuario.

#### Ejemplo: Usar `navigator.languages`

```javascript
const userLanguages = navigator.languages;
console.log(userLanguages); // Ejemplo: ["en-US", "fr-FR", "es-ES"]

const primaryLanguage = userLanguages[0];
console.log(primaryLanguage); // Ejemplo: "en-US"
```

### Resumen

`Navigator.language` es una forma sencilla y √∫til de acceder al idioma preferido del usuario en su navegador. Puedes usar esta informaci√≥n para personalizar la experiencia del usuario en tu aplicaci√≥n web, como mostrar contenido en el idioma correcto o ajustar otros aspectos basados en la preferencia de idioma del usuario.

## 19. Deploy

- Ver notas en Obsidian [[gh-pages]]
- Ver notas en GitHub [gh-pages](https://github.com/aleroses/Platzi/blob/master/DW/1-basico/005-git-github/gh-pages.md)

https://developer.themoviedb.org/reference/configuration-details

https://lauramunozcaiced.github.io/lmovies/

```bash
git push origin development
```

## 20. M√°s proyectos para tu portafolio

## Examen üìå
<details>
	<summary>Haz clic para ver los resultados üëÄ</summary>
	<br/>

1. ¬øQu√© es cach√©?

	- ‚úÖ Cuando el navegador guarda la respuesta de una consulta HTTP para no hacer esa misma consulta de nuevo durante un rango de tiempo seguro.

2. ¬øQu√© problemas podemos tener si implementamos t√©cnicas como cach√© o memoization?

	- ‚úÖ No sabremos si la informaci√≥n cambi√≥ en el backend hasta que volvamos a hacer la consulta HTTP.

3. Agregar nuestra API KEY a un archivo ignorado por el .gitignore nos asegura protecci√≥n completa y es una muy buena pr√°ctica.

	- ‚úÖ S√≠, pero no. Nadie podr√° ver nuestra API KEY desde el repositorio. Pero al hacer deploy nuestra API KEY debe ser visible de alguna forma desde el navegador para el correcto funcionamiento de la aplicaci√≥n.

4. Trabajas como frontend developer en Facebook. La empresa ya no quiere enfocarse en buscar p√∫blico m√°s joven, sino en atender mejor al p√∫blico mayor que sigue usando la red social. Tu equipo propone cambiar el scroll infinito por paginaci√≥n porque "la gente mayor ya no est√° para esos trotes". ¬øQu√© opinas?

	- ‚úÖ No vale la pena. Cambiar el infinite scroll por paginaci√≥n bajar√≠a la adictividad del sitio, incluso con personas mayores.

5. Es muy buena pr√°ctica que la pantalla de error y la pantalla de carga sean exactamente iguales para evitar que los usuarios se lleven una mala impresi√≥n de nuestra aplicaci√≥n.

	- ‚úÖ Falso

6. Trabajas como frontend developer en un peri√≥dico digital con aproximadamente 5 noticias a la semana. Los clientes piden mejorar la velocidad para ver sus noticias. Tu equipo propone solucionarlo implementando cach√© en la plataforma web. ¬øQu√© opinas?

	- ‚úÖ Absolutamente s√≠: aunque el cach√© no mejorar√≠a la velocidad en la primera consulta de cada lector, s√≠ la mejorar√≠a en las siguientes veces que entre o navegue por el portal.

7. Trabajas como frontend developer en una tienda online de celulares. La empresa necesita mejorar las ventas. Tu equipo propone cambiar la paginaci√≥n por infinite scrolling para que la tienda sea mucho m√°s adictiva. ¬øQu√© opinas?

	- ‚úÖ No vale la pena. Aunque implementar infinite scroll ayudar√≠a a aumentar la adicci√≥n de los usuarios, bajar√≠a las ventas porque generar√≠a frustraci√≥n al dificultar encontrar contenido espec√≠fico.

8. La cantidad de usuarios que abandona nuestro sitio web incrementa dram√°ticamente por cada segundo que tarda nuestro contenido en cargar.
	
	- ‚úÖ Verdadero

9. Tu aplicaci√≥n demora algunos segundos en cargar completamente mientras hace consultas a la API REST. ¬øQu√© har√≠as?
	
	- ‚úÖ Agregar loading skeletons para que los usuarios sepan que estamos cargando la informaci√≥n (y sepan qu√© tipo de contenido se est√° cargando).

10. ¬øQu√© es memoization?

	- ‚úÖ Guardar los c√°lculos de la aplicaci√≥n (en memoria, durante la ejecuci√≥n de nuestro c√≥digo) para no tener que repetirlos.

11. Al aprender Axios evitamos la necesidad de aprender Fetch. Esta afirmaci√≥n es:

	- ‚úÖ Falsa

12. ¬øCu√°l pesta√±a de las DevTools de tu navegador nos permite examinar las consultas HTTP (y el tiempo que tarda cada una)?

	- ‚úÖ Networking

13. ¬øQu√© podemos hacer desde el frontend para mejorar la velocidad de nuestras aplicaciones web?

	- ‚úÖ Utilizar t√©cnicas de cach√© o memoization para no cargar m√°s una vez los recursos que necesitamos.

14. Combinar datos de Local Storage con datos de una API REST es una MALA PR√ÅCTICA.

	- ‚úÖ Falso.

15. ¬øCu√°l de los siguientes datos son seguros para guardar en Local Storage?

	- N√∫meros de tarjeta de cr√©dito o d√©bito.
	- ‚úÖ Ninguna de las respuestas es correcta.
	- Tokens de autenticaci√≥n.
	- Correo y contrase√±a.

16. Es muy buena pr√°ctica que nuestra pantalla de carga sea divertida.
Elige la respuesta correcta

	- ‚úÖ Verdadero. Las pantallas de carga pueden ser divertidas DEPENDIENDO del tono de nuestra aplicaci√≥n. SIEMPRE deben ser al menos tolerables y f√°ciles de reconocer.

17. Trabajas como frontend developer en un banco con aproximadamente 5 millones de transacciones al d√≠a. Los clientes piden mejorar la velocidad para ver su dinero y transacciones. Tu equipo propone solucionarlo implementando cach√© en la plataforma web. ¬øQu√© opinas?

	- ‚úÖ Absolutamente no: el cach√© mejorar√≠a la velocidad, pero podr√≠a mostrar informaci√≥n desactualizada bastante seguido.

</details>


‚úÖ 
üî•
üìå
üëàüëÄ
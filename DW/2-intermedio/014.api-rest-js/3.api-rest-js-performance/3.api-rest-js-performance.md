# Curso de API REST con Javascript: Performance y Usabilidad

> 09/06/2024


## 1. Tu responsabilidad como frontend developer

## 2. Cach√© vs. memoria

### Cache (kÀà√¶ É)

Cache es la forma en la que le decimos al navegador que nos traiga la √∫ltima informaci√≥n guardada, es decir que si necesitamos algo de informaci√≥n simplemente env√≠e lo que tiene en cache.

**Propiedades**

- default -
- no-store -
- reload -
- no-cache -
- force-cache -
- only-if-cached -

Estos son todos los ‚Äúcondicionales‚Äù que el cach√© permite validar el ‚Äúestado‚Äù de la informaci√≥n.

### Memorization

Memoization (Si se escribe as√≠!!) Guardar los c√°lculos ‚ÄùPeticiones‚Äù que ya hicimos para no repetirlos.

### **Posibles Problemas**

- Nosotros no sabemos si ha cambiado la informaci√≥n del back-end.
- Nosotros no sabemos si la cache o memorization est√° actualizada o des-actualizada.

En resumen es:

Crear un objeto. Preguntar si el objeto tiene la informaci√≥n que necesitamos Si s√≠, usar la informaci√≥n Si no, hacer el fetch y guardar la informaci√≥n en el objeto 

Consideraciones importantes.

JavaScript √∫nicamente guarda la informaci√≥n en tiempo de ejecuci√≥n si esta informaci√≥n se hace reload se va a perder.

## 3. Debuggeando cach√© y networking

Descarga el proyecto anterior

[[debugging-devtools#16. ¬øCu√°ndo utilizar Network en DevTools?]]

## Quiz: Qu√© se debe optimizar en el frontend (y qu√© no)

1. ¬øQu√© t√©cnicas se pueden utilizar para maximizar la eficiencia de la carga de datos?

	- Cach√©

2. ¬øPor qu√© es importante considerar la carga y optimizaci√≥n de datos en el frontend?

	- Para brindar una buena experiencia a los usuarios

3. How does memorization improve the performance of an application?

	- By avoiding the repetition of complex computations.

3. ¬øQu√© se menciona acerca de la funci√≥n de recarga de la p√°gina?

	- Se explica c√≥mo se recargan diferentes elementos al realizar una recarga fuerte.

4. What is memorization in JavaScript?

	- A technique to store previously computed results or API responses.

## 4. Loading spinners vs. loading skeletons

Buenas caracter√≠sticas de las pantallas de carga:

- Facilitan la comprensi√≥n del estado de carga
- Son amigables con el tiempo de carga
- Hacen que la experiencia de carga sea divertida

Tenemos dos estrategias principales para manejar las pantallas de carga:

### Loading spinners

- Un anillo animado que indica que algo se est√° cargando
- No proporciona informaci√≥n clara sobre lo que se est√° cargando
- No nos permite saber si hemos perdido la conexi√≥n WiFi o si la web se ha bloqueado

### Loading skeletons

- Tienen buenas pr√°cticas que los usuarios disfrutan
- Proporcionan una representaci√≥n visual de lo que se est√° cargando, lo que hace que la espera sea m√°s informativa
- Pueden reducir la percepci√≥n del tiempo de carga al mostrar la estructura de la p√°gina mientras se cargan los contenidos detallados

![](https://i.postimg.cc/hvRwMjDH/4-spinner-skeleton-loader.jpg)

## 5. Reto: pantalla de carga

Ejemplo de Animaci√≥n simple:

`index.html`

```html
<section class="container">
  <div class="item loading"></div>
  <div class="item loading"></div>
  <div class="item loading"></div>
  <div class="item loading"></div>
</section>
```

`styles.css`

```css
.container {
  display: flex;
  gap: 30px;
}
.item {
  width: 80px;
  height: 80px;
  background-color: darkslateblue;
}

.loading {
  animation: insane infinite 1.5s;
}

@keyframes insane {
  0%,
  100% {
    opacity: 100%;
  }

  50% {
    opacity: 50%;
  }
}
```

![](https://i.postimg.cc/tCmR2bk3/5-animation.png)

## 6. Intersection Observer

[[manipulacion-dom#Curso de Manipulaci√≥n del DOM#22. Intersection Observer]]

V√≠deos que pueden ayudarte a practicar; adem√°s, complementar a√∫n m√°s el conocimiento del curso.

- [Intersection Observer](https://www.youtube.com/watch?v=cVsqA4NhDoI&t=33s)
- [Scroll Infinito](https://www.youtube.com/watch?v=m5yS-RsKGTw&t=3s)

## 7. Lazy Loading

[[manipulacion-dom#23. Aplicando Lazy loading#Atributos data*]]

## 8. Im√°genes por defecto

Tener cuidado con la medida o tama√±o de las im√°genes al cargar, esto podr√≠a estar afectando el Lazy Loading. Por lo que se recomienda a√±adir un `min-height` desde el inicio y despu√©s sobreescribirlo con la medida real.

## Quiz: Optimizaci√≥n de im√°genes

1. What approach does the author prefer for solving the problem of lazy loading?

	- Using an intersection observer in JavaScript

2. ¬øPor qu√© la ruedita de carga no cumple con las pr√°cticas adecuadas?

	- No indica qu√© se est√° cargando ni cu√°nto tiempo falta.

3. What is the initial visibility of the images when the page is reloaded?

	- Only one specific image is visible

4. ¬øQu√© es Lazy Lading?

	- Indicarle a nuestras im√°genes que no carguen todas desde el principio, sino √∫nicamente cuando los usuarios lleguen a esa parte de la app.

5. ¬øQu√© es el churn rate?

	- La cantidad de usuarios que entran a nuestra app, pero luego la abandonan.

## 9. Scroll infinito vs. paginaci√≥n

## 10. Bot√≥n de cargar m√°s

## 11. Infinite Scrolling: evento de scroll

### Qu√© es `document.documentElement`

`document.documentElement` es una propiedad de solo lectura del objeto `document` en el DOM (Document Object Model). Representa el elemento ra√≠z del documento, que es el elemento `<html>` en un documento HTML.

A trav√©s de esta propiedad, se puede acceder y manipular el contenido y los atributos del elemento `<html>` directamente. 

### C√≥mo funciona

El elemento `<html>` es el contenedor principal de todo el contenido de una p√°gina web, y `document.documentElement` proporciona una referencia directa a este elemento. Al acceder a `document.documentElement`, puedes manipular el elemento `<html>` de la misma manera que lo har√≠as con cualquier otro nodo del DOM.

### Propiedades y Atributos Comunes

El elemento `document.documentElement`, que corresponde al elemento `<html>` en un documento HTML, tiene varios atributos y propiedades que puedes utilizar. A continuaci√≥n, se detallan algunos de los m√°s importantes y c√≥mo se pueden usar:

#### 1. Acceder al elemento `<html>`

Puedes acceder al elemento `<html>` y leer sus atributos o propiedades:

```javascript
// Acceder al elemento <html>
var htmlElement = document.documentElement;

console.log(htmlElement); // Muestra el elemento <html> completo
```

#### 2. Cambiar el idioma del documento

Puedes cambiar el atributo `lang` del elemento `<html>`:

```javascript
// Cambiar el idioma del documento a espa√±ol
document.documentElement.lang = "es";

// Cambiar el idioma del documento al ingl√©s
document.documentElement.lang = "en";
```

#### 3. Aplicar estilos al elemento `<html>`

Puedes aplicar estilos directamente al elemento `<html>` usando `document.documentElement`:

```javascript
// Cambiar el color de fondo del elemento <html>
document.documentElement.style.backgroundColor = "lightblue";
```

#### 4. Obtener el ancho y alto del viewport

`document.documentElement` es √∫til para obtener el tama√±o del viewport (la parte visible de la p√°gina):

```javascript
// Obtener el ancho del viewport
var viewportWidth = document.documentElement.clientWidth;

// Obtener el alto del viewport
var viewportHeight = document.documentElement.clientHeight;

console.log("Ancho del viewport:", viewportWidth);
console.log("Alto del viewport:", viewportHeight);
```

#### 5. Desplazamiento del documento

Estas propiedades devuelven o establecen la posici√≥n de desplazamiento vertical y horizontal del documento.

```javascript
// Obtener la posici√≥n de desplazamiento vertical
var scrollTop = document.documentElement.scrollTop;

console.log("Posici√≥n de desplazamiento vertical:", scrollTop);

// Establecer la posici√≥n de desplazamiento vertical
document.documentElement.scrollTop = 100;

// Obtener la posici√≥n de desplazamiento horizontal
var scrollLeft = document.documentElement.scrollLeft;

console.log("Posici√≥n de desplazamiento horizontal:", scrollLeft);

// Establecer la posici√≥n de desplazamiento horizontal
document.documentElement.scrollLeft = 100;
```

#### 6. `document.documentElement.dir`

Este atributo establece o devuelve la direcci√≥n del texto del documento (`ltr` para izquierda a derecha o `rtl` para derecha a izquierda).

```javascript
// Obtener la direcci√≥n del texto del documento
var dir = document.documentElement.dir;

console.log("Direcci√≥n del texto del documento:", dir);

// Establecer la direcci√≥n del texto del documento a derecha a izquierda
document.documentElement.dir = "rtl";
```

#### 7. `document.documentElement.title`

Aunque generalmente se accede y se manipula a trav√©s del elemento `<title>`, tambi√©n puedes acceder al t√≠tulo del documento a trav√©s de `document.documentElement`.

```javascript
// Obtener el t√≠tulo del documento
var title = document.title;

console.log("T√≠tulo del documento:", title);

// Establecer un nuevo t√≠tulo para el documento
document.title = "Nuevo T√≠tulo";
```

### Propiedades del Documento

#### `document.documentElement.offsetWidth` y `document.documentElement.offsetHeight`

Estas propiedades devuelven el ancho y el alto del elemento `<html>` incluyendo los bordes.

```javascript
// Obtener el ancho del elemento <html> incluyendo los bordes
var offsetWidth = document.documentElement.offsetWidth;

// Obtener el alto del elemento <html> incluyendo los bordes
var offsetHeight = document.documentElement.offsetHeight;

console.log("Ancho del elemento <html>:", offsetWidth);
console.log("Alto del elemento <html>:", offsetHeight);
```

**Dato**:

- Usa `clientHeight` cuando necesitas saber la altura del √°rea visible al usuario.
- Usa `offsetHeight` cuando necesitas la altura total del elemento, incluyendo los bordes y el scrollbar. üìå Su comportamiento puede variar.

Adem√°s:

```js
// Incluye solo el padding, no los bordes.
document.documentElement.scrollHeight
```

### M√©todos de Manipulaci√≥n

#### `document.documentElement.getBoundingClientRect()`

Este m√©todo devuelve un objeto `DOMRect` que proporciona informaci√≥n sobre el tama√±o del elemento y su posici√≥n relativa al viewport.

```javascript
// Obtener las dimensiones y la posici√≥n del elemento <html>
var rect = document.documentElement.getBoundingClientRect();

console.log("Dimensiones y posici√≥n del elemento <html>:", rect);
```

Ejemplo:

```js
DOMRect {
    "x": 0,
    "y": -304,
    "width": 320,
    "height": 964,
    "top": -304,
    "right": 320,
    "bottom": 660,
    "left": 0
}
```

üìå Lo curioso es que si sumamos `document.documentElement.scrollTop + document.documentElement.clientHeight` obtendremos el total de scroll que podemos hacer.

![](https://i.postimg.cc/02dcnZw3/11-scroll.png)

### üî• `window.removeEventListener("scroll", infiniteScroll, ¬øparametro?üëàüëÄ);`

El tercer par√°metro en los m√©todos `addEventListener` y `removeEventListener` se utiliza para especificar opciones adicionales para el evento. Este par√°metro puede ser un valor booleano (true o false) o un objeto de opciones. 

#### Uso del tercer par√°metro en `removeEventListener`

El tercer par√°metro en `removeEventListener` **debe coincidir** con el tercer par√°metro utilizado en `addEventListener` para que la eliminaci√≥n del evento sea efectiva.

#### Casos de uso y aplicaci√≥n en `addEventListener`

En `addEventListener`, el tercer par√°metro puede ser un booleano o un objeto. Aqu√≠ hay un resumen:

1. **Booleano (`true` o `false`)**:
   - **`true`**: La fase de captura. El evento se captura en la fase de captura, antes de llegar al objetivo del evento.
   - **`false`**: La fase de burbuja. El evento se maneja en la fase de burbuja, despu√©s de que se ha propagado desde el objetivo hacia afuera. Este es el comportamiento predeterminado.

2. **Objeto de opciones**: Este objeto puede tener varias propiedades, como:
   - **`capture`** (booleano): Equivalente a usar `true` o `false` directamente.
   - **`once`** (booleano): Si es `true`, el evento se ejecuta solo una vez y luego se elimina autom√°ticamente.
   - **`passive`** (booleano): Si es `true`, indica que el manejador de eventos nunca llamar√° a `preventDefault`, mejorando el rendimiento en algunos casos como el desplazamiento (scrolling) o en eventos como `touchstart` y `touchmove`.

#### Ejemplo de `removeEventListener` y `addEventListener`

```javascript
// Definimos una funci√≥n de manejo de eventos
function infiniteScroll() {
    console.log('Scrolled');
}

// A√±adimos el evento usando un objeto de opciones
window.addEventListener("scroll", infiniteScroll, {
  capture: false,
  passive: true,
  once: false
});

// M√°s tarde, removemos el evento usando los mismos par√°metros
window.removeEventListener("scroll", infiniteScroll, {
  capture: false,
  passive: true
});
```

#### Fase de captura y fase de burbuja

- **Fase de captura (true)**: En esta fase, el evento se propaga desde el elemento `window` (o el m√°s alto en el DOM) hacia el objetivo del evento. Si se establece el tercer par√°metro como `true` o se usa `{ capture: true }`, el evento ser√° capturado durante esta fase.

- **Fase de burbuja (false)**: Despu√©s de que el evento alcanza su objetivo, comienza a propagarse de regreso hacia el elemento `window` (o el m√°s alto en el DOM). üî• Este es el comportamiento predeterminado, y se puede especificar con `false` o `{ capture: false }`.

##### Ejemplo de `addEventListener` con booleano

```javascript
// Definimos una funci√≥n de manejo de eventos
function handleClick(event) {
    console.log('Clicked', event.target);
}

// A√±adimos el evento para la fase de burbuja
document.getElementById('myElement').addEventListener('click', handleClick, false);

// A√±adimos el evento para la fase de captura
document.getElementById('myElement').addEventListener('click', handleClick, true);

// Removemos el evento para la fase de burbuja
document.getElementById('myElement').removeEventListener('click', handleClick, false);

// Removemos el evento para la fase de captura
document.getElementById('myElement').removeEventListener('click', handleClick, true);
```

En resumen, el tercer par√°metro en `addEventListener` y `removeEventListener` proporciona un control m√°s granular sobre c√≥mo y cu√°ndo se deben manejar los eventos, y su uso correcto es esencial para la gesti√≥n eficiente de eventos en aplicaciones web.

#### `preventDefault` y su Relaci√≥n con los Eventos

`preventDefault` es un m√©todo que se usa en el manejo de eventos para evitar el comportamiento predeterminado del navegador asociado con el evento. Por ejemplo:

- Evitar que un enlace (`<a>`) navegue a otra p√°gina.
- Evitar que un formulario (`<form>`) se env√≠e.
- Evitar el comportamiento de desplazamiento (scroll) en ciertos eventos.

##### Ejemplo de `preventDefault`

```javascript
document.getElementById('myLink').addEventListener('click', function(event) {
    event.preventDefault(); // Evita que el enlace navegue
    console.log('Enlace clickeado, pero navegaci√≥n evitada.');
});
```

#### Par√°metro `passive`

El par√°metro `passive` en `addEventListener` es una optimizaci√≥n de rendimiento. Cuando `passive` se establece en `true`, le indica al navegador que el manejador de eventos no llamar√° a `preventDefault`. Esto permite que el navegador optimice el rendimiento en algunos casos, como el desplazamiento (scroll), ya que el navegador no necesita esperar a ver si `preventDefault` ser√° llamado.

##### Relaci√≥n entre `passive` y `preventDefault`

- **`passive: true`**: Indica que el evento es "pasivo". No se llamar√° a `preventDefault` en el manejador de eventos.
  - Ventaja: Mejor rendimiento, especialmente para eventos de desplazamiento (scroll), ya que el navegador puede proceder con el comportamiento predeterminado sin esperar a que el manejador del evento lo bloquee.
  - Restricci√≥n: Intentar llamar a `preventDefault` lanzar√° un error en la consola.

- **`passive: false`**: Indica que el evento es "activo". Se puede llamar a `preventDefault` para evitar el comportamiento predeterminado.
  - Ventaja: Permite prevenir el comportamiento predeterminado del navegador.
  - Desventaja: Puede resultar en un rendimiento menos √≥ptimo en algunos casos, como el desplazamiento (scroll), porque el navegador necesita esperar para ver si `preventDefault` ser√° llamado.

##### Ejemplo de `passive`

###### Con `passive: true`

```javascript
window.addEventListener('scroll', function(event) {
    console.log('Scrolled');
}, { passive: true });

// Este c√≥digo no funciona si se intenta llamar a preventDefault dentro del manejador:
// window.addEventListener('scroll', function(event) {
//     event.preventDefault(); // Esto lanzar√° un error
// }, { passive: true });
```

###### Con `passive: false`

```javascript
window.addEventListener('scroll', function(event) {
    event.preventDefault(); // Esto es permitido
    console.log('Scrolled and default behavior prevented');
}, { passive: false });
```

El valor por defecto del par√°metro `passive` es `false`. Esto significa que, a menos que se especifique expl√≠citamente lo contrario, los manejadores de eventos se tratar√°n como no pasivos, permitiendo el uso de `preventDefault` dentro del manejador de eventos.

Si no se especifica el par√°metro `passive`, se asume `false` por defecto:

```javascript
// Sin especificar passive, se asume passive: false
window.addEventListener('scroll', function(event) {
    event.preventDefault(); // Esto es permitido por defecto
    console.log('Scrolled and default behavior prevented');
});
```

En resumen:

- **`preventDefault`**: M√©todo para prevenir el comportamiento predeterminado del navegador asociado con el evento.
- **`passive`**: Un par√°metro en `addEventListener` que, cuando se establece en `true`, indica que no se llamar√° a `preventDefault` en el manejador de eventos, permitiendo optimizaciones de rendimiento.
- **Valor por defecto de `passive`**: `false`.
- **Comportamiento predeterminado**: Permite el uso de `preventDefault`.
- **Relaci√≥n**: Si `passive` es `true`, no se puede usar `preventDefault` en el manejador de eventos. Si `passive` es `false`, se puede usar `preventDefault`, pero puede impactar el rendimiento.
- **Especificar `passive: true`**: Indica que `preventDefault` no se usar√°, mejorando el rendimiento para ciertos eventos.

Usar `passive: true` es una buena pr√°ctica para eventos de desplazamiento (scroll) y otros eventos de alta frecuencia, donde no se necesita prevenir el comportamiento predeterminado.

#### üìå Dato

`Passive` lo que hace es evitar el llamado de `preventDefault()` en el caso de que este existiese en la funci√≥n llamada por el Listener. 

En los navegadores que usa la gente normal el valor **por defecto es false** por lo que no se aplica, pero en el caso de Safari e Internet Explorer el valor por defecto es true. 

Por lo que supongo que es recomendable ponerle un valor para que el c√≥digo se ejecute igual en todos los navegadores.

## 12. Infinite Scrolling: limitando la carga de datos

## 13. Infinite Scrolling: closures de navegaci√≥n

[[closures_scope-en-js#**7.** ¬øQu√© es un Closure?]]


üî•
üìå
üëàüëÄ